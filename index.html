<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PLAC Cáceres — Painel Climático (Mensal/Anual)</title>

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

  <!-- PapaParse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- pako (gzip inflate) -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

  <style>
    :root{
      --bg0:#06070b;
      --bg1:#0b1220;
      --card:rgba(255,255,255,.06);
      --card2:rgba(255,255,255,.08);
      --line:rgba(255,255,255,.12);
      --text:#eaf0ff;
      --muted:#a7b2cc;

      --blue:#2d6cdf;
      --green:#22c55e;
      --red:#ef4444;
      --amber:#f59e0b;
      --purple:#a855f7;
      --cyan:#22d3ee;

      --shadow:0 18px 50px rgba(0,0,0,.45);
      --r:18px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% 20%, rgba(45,108,223,.35), transparent 60%),
        radial-gradient(1000px 700px at 80% 70%, rgba(34,197,94,.25), transparent 60%),
        radial-gradient(900px 600px at 80% 20%, rgba(239,68,68,.22), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
    }

    header{
      position:sticky; top:0; z-index:20;
      backdrop-filter: blur(10px);
      background: linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.25));
      border-bottom:1px solid rgba(255,255,255,.08);
    }

    .wrap{max-width:1220px;margin:0 auto;padding:16px}
    .top{
      display:flex;gap:14px;align-items:center;justify-content:space-between;flex-wrap:wrap;
    }
    .brand{display:flex;gap:12px;align-items:center}
    .logo{
      width:38px;height:38px;border-radius:12px;
      background: conic-gradient(from 180deg, var(--blue), var(--cyan), var(--green), var(--amber), var(--red), var(--purple), var(--blue));
      box-shadow: 0 10px 28px rgba(0,0,0,.35);
    }
    h1{margin:0;font-size:16px;line-height:1.2}
    .sub{margin:2px 0 0;color:var(--muted);font-size:12px}

    .actions{display:flex;gap:10px;flex-wrap:wrap}
    .btn{
      border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      color:var(--text);
      border-radius:999px;
      padding:10px 14px;
      cursor:pointer;
      box-shadow: var(--shadow);
      font-weight:700;
      font-size:13px;
      transition:.15s transform ease;
      user-select:none;
    }
    .btn:hover{transform: translateY(-1px)}
    .btn.blue{border-color:rgba(45,108,223,.35); box-shadow:0 14px 40px rgba(45,108,223,.14)}
    .btn.green{border-color:rgba(34,197,94,.35); box-shadow:0 14px 40px rgba(34,197,94,.14)}
    .btn.red{border-color:rgba(239,68,68,.35); box-shadow:0 14px 40px rgba(239,68,68,.14)}
    .btn.ghost{opacity:.9}

    main .grid{
      max-width:1220px;
      margin:0 auto;
      padding:16px;
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:14px;
    }

    .panel, .viz{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .panel{padding:14px}
    .panel h2{
      margin:0 0 10px;
      font-size:13px;
      color:#d7deee;
      font-weight:800;
      letter-spacing:.2px;
    }

    .note{
      background: rgba(45,108,223,.10);
      border:1px solid rgba(45,108,223,.18);
      padding:10px 10px;
      border-radius: 14px;
      color:#cfe2ff;
      font-size:12px;
      margin-bottom:12px;
      line-height:1.35;
    }

    label{display:block;font-size:12px;color:var(--muted);margin:10px 0 6px}
    select, input{
      width:100%;
      background: rgba(0,0,0,.25);
      color:var(--text);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 12px;
      padding:10px 10px;
      outline:none;
      font-size:13px;
    }
    .row{display:grid;grid-template-columns:1fr 1fr; gap:10px}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr; gap:10px}

    .chips{
      display:flex;gap:8px;flex-wrap:wrap;margin-top:8px
    }
    .chip{
      padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      font-size:12px;color:#d7deee;
      cursor:pointer; user-select:none;
    }
    .chip.on{border-color:rgba(34,197,94,.45); background: rgba(34,197,94,.12)}

    .cards{
      display:grid;grid-template-columns:1fr 1fr 1fr; gap:10px; margin-top:12px
    }
    .card{
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding:10px;
      min-height:72px;
    }
    .k{font-size:11px;color:var(--muted);font-weight:700}
    .v{font-size:16px;font-weight:900;margin-top:3px}
    .small{font-size:11px;color:#c8d2ea;margin-top:2px}

    .status{
      margin-top:10px;
      font-size:12px;
      color:#cfe2ff;
      padding:10px;
      border-radius:14px;
      border:1px dashed rgba(255,255,255,.18);
      background: rgba(0,0,0,.18);
      line-height:1.35;
      white-space:pre-wrap;
    }
    .status.bad{border-color:rgba(239,68,68,.30); color:#ffd2d2}
    .status.ok{border-color:rgba(34,197,94,.30); color:#d7ffe5}

    .viz{padding:10px}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;margin:6px 6px 10px}
    .tab{
      padding:8px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color:#d7deee;
      cursor:pointer;
      font-size:12px;
      font-weight:800;
      user-select:none;
    }
    .tab.on{border-color:rgba(45,108,223,.45); background: rgba(45,108,223,.12)}
    #plot{height: 610px; width:100%}

    footer{
      max-width:1220px;
      margin:0 auto;
      padding:0 16px 18px;
      color:rgba(255,255,255,.55);
      font-size:12px;
    }
    footer b{color:rgba(255,255,255,.75)}

    @media (max-width: 980px){
      main .grid{grid-template-columns:1fr}
      #plot{height: 560px}
    }
  </style>
</head>

<body>
<header>
  <div class="wrap">
    <div class="top">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>PLAC Cáceres — Painel Climático (Mensal/Anual)</h1>
          <div class="sub">Dados + estatística + gráficos claros para decisão pública (Cáceres/MT)</div>
        </div>
      </div>
      <div class="actions">
        <button class="btn blue" id="btnPNG">Salvar gráfico (PNG)</button>
        <button class="btn green" id="btnCSV">Exportar seleção (CSV)</button>
        <button class="btn red" id="btnReset">Reset</button>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="grid">
    <section class="panel">
      <h2>Controles — Cáceres (MT)</h2>

      <div class="note">
        <b>Objetivo:</b> permitir que qualquer pessoa (leiga ou técnica) veja
        <b>tendência</b>, <b>sazonalidade</b>, <b>variabilidade</b> e <b>relações entre variáveis</b>,
        com estatística transparente e exportável.
        <br><br>
        <b>Organizador:</b> Ernandes Sobreira Oliveira Junior (uso educacional e políticas públicas).
      </div>

      <label>Escala</label>
      <select id="selScale">
        <option value="monthly">Mensal</option>
        <option value="annual">Anual</option>
      </select>

      <label>Variável (indicador)</label>
      <select id="selVar"></select>

      <div class="row">
        <div>
          <label>Ano (início)</label>
          <input id="yr0" type="number" />
        </div>
        <div>
          <label>Ano (fim)</label>
          <input id="yr1" type="number" />
        </div>
      </div>

      <label>Meses (apenas para escala mensal)</label>
      <div class="row">
        <div>
          <select id="selMonthMode">
            <option value="all">Todos os meses</option>
            <option value="one">Um mês</option>
            <option value="many">Vários meses</option>
          </select>
        </div>
        <div>
          <select id="selOneMonth" disabled></select>
        </div>
      </div>

      <div class="chips" id="monthChips" style="opacity:.55; pointer-events:none"></div>

      <div class="row">
        <div>
          <label>Tendência (modelo)</label>
          <select id="selTrend">
            <option value="none">Sem tendência</option>
            <option value="linear">Linear</option>
            <option value="poly2">Polinomial (grau 2)</option>
            <option value="poly3">Polinomial (grau 3)</option>
            <option value="exp">Exponencial</option>
            <option value="logistic">Logística</option>
          </select>
        </div>
        <div>
          <label>Defasagem (lag) p/ dispersão</label>
          <select id="selLag"></select>
        </div>
      </div>

      <label>Dispersão (comparar 2 variáveis)</label>
      <div class="row">
        <select id="selX"></select>
        <select id="selY"></select>
      </div>

      <div class="cards">
        <div class="card">
          <div class="k">Mín (seleção)</div>
          <div class="v" id="kMin">—</div>
          <div class="small" id="kMin2"></div>
        </div>
        <div class="card">
          <div class="k">Mediana (seleção)</div>
          <div class="v" id="kMed">—</div>
          <div class="small" id="kMed2"></div>
        </div>
        <div class="card">
          <div class="k">Máx (seleção)</div>
          <div class="v" id="kMax">—</div>
          <div class="small" id="kMax2"></div>
        </div>
      </div>

      <div class="status" id="status">Carregando dados…</div>
    </section>

    <section class="viz">
      <div class="tabs">
        <div class="tab on" data-tab="ts">Série temporal</div>
        <div class="tab" data-tab="box">Boxplot (meses)</div>
        <div class="tab" data-tab="scat">Dispersão + regressão</div>
        <div class="tab" data-tab="tbl">Tabela</div>
      </div>
      <div id="plot"></div>
    </section>
  </div>
</main>

<footer>
  <div class="wrap" style="padding:0">
    <b>PLAC Cáceres — Painel Climático</b> • Organizador: Ernandes Sobreira Oliveira Junior • fins educacionais e políticas públicas • dados agregados Mensal/Anual.
  </div>
</footer>

<script>
/* ===========================
   CONFIG
=========================== */
const DATA_URL = "data/caceres_keyvars_monthly_annual.csv.gz"; // precisa existir no repo!

const MONTHS_PT = ["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"];
const COLORS_MONTH = ["#2d6cdf","#f59e0b","#22c55e","#ef4444","#a855f7","#22d3ee","#fb7185","#c084fc","#eab308","#38bdf8","#60a5fa","#f97316"];

const VAR_META = {
  // ajuste aqui se quiser mudar rótulos/unidades (depende do teu CSV mensal/anual)
  // o painel também aceita colunas extras e tenta inferir se não estiver listado
  precipitation:          {label:"Precipitação", unit:"mm"},
  temperature_2m:         {label:"Temperatura do ar (2 m)", unit:"°C"},
  dewpoint_2m:            {label:"Ponto de orvalho (2 m)", unit:"°C"},
  relative_humidity_2m:   {label:"Umidade relativa (2 m)", unit:"%"},
  surface_solar_radiation:{label:"Radiação solar", unit:"MJ/m²"},
  net_solar_radiation:    {label:"Radiação solar líquida", unit:"MJ/m²"},
  soil_moisture_layer1:   {label:"Umidade do solo (camada 1)", unit:"m³/m³"},
  soil_moisture_layer2:   {label:"Umidade do solo (camada 2)", unit:"m³/m³"},
  evap_canopy:            {label:"Evaporação do dossel (canopy)", unit:"mm"},
  evap_soil:              {label:"Evaporação do solo", unit:"mm"},
  evap_total:             {label:"Evapotranspiração (total)", unit:"mm"},
  wind_speed_10m:         {label:"Velocidade do vento (10 m)", unit:"m/s"}
};

/* ===========================
   STATE
=========================== */
const state = {
  raw: [],
  cols: [],
  ready: false,
  tab: "ts",
  lastFiltered: []
};

const el = (id)=>document.getElementById(id);
const fmt = (x)=> (x===null||x===undefined||Number.isNaN(x)) ? "—" : (Math.abs(x)>=1000 ? x.toFixed(0) : x.toFixed(2));
const isNum = (x)=> typeof x === "number" && !Number.isNaN(x) && Number.isFinite(x);

/* ===========================
   HELPERS: stats
=========================== */
function median(arr){
  if(!arr.length) return NaN;
  const a = [...arr].sort((x,y)=>x-y);
  const m = Math.floor(a.length/2);
  return a.length%2 ? a[m] : (a[m-1]+a[m])/2;
}
function quantile(arr,q){
  if(!arr.length) return NaN;
  const a=[...arr].sort((x,y)=>x-y);
  const pos=(a.length-1)*q;
  const base=Math.floor(pos);
  const rest=pos-base;
  if(a[base+1]===undefined) return a[base];
  return a[base]+rest*(a[base+1]-a[base]);
}
function r2Score(y, yhat){
  const n = Math.min(y.length, yhat.length);
  const yy = y.slice(0,n);
  const yh = yhat.slice(0,n);
  const ybar = yy.reduce((s,v)=>s+v,0)/n;
  let ssRes=0, ssTot=0;
  for(let i=0;i<n;i++){
    ssRes += (yy[i]-yh[i])**2;
    ssTot += (yy[i]-ybar)**2;
  }
  return ssTot===0 ? NaN : (1 - ssRes/ssTot);
}

/* ===========================
   TREND FITS
=========================== */
function fitLinear(x,y){
  const n=x.length;
  const sx=x.reduce((s,v)=>s+v,0);
  const sy=y.reduce((s,v)=>s+v,0);
  const sxx=x.reduce((s attaching=>s attaching,0),0);
  const sxy=x.reduce((s,v,i)=>s+v*y[i],0);
  const sxx2=x.reduce((s,v)=>s+v*v,0);
  const denom = (n*sxx2 - sx*sx);
  if(denom===0) return null;
  const a = (n*sxy - sx*sy)/denom; // slope
  const b = (sy - a*sx)/n; // intercept
  const yhat = x.map(xx=>a*xx+b);
  return {yhat, desc:`Linear: y = ${a.toFixed(4)}·t + ${b.toFixed(4)}`, r2:r2Score(y,yhat)};
}

function polyFit(x,y,deg){
  // least squares normal equations
  const n=x.length;
  const X = Array.from({length:deg+1}, (_,p)=> x.map(xx=>xx**p)); // basis
  // build A = X*X^T, b = X*y
  const A = Array.from({length:deg+1}, ()=>Array(deg+1).fill(0));
  const B = Array(deg+1).fill(0);
  for(let i=0;i<deg+1;i++){
    for(let j=0;j<deg+1;j++){
      let s=0;
      for(let k=0;k<n;k++) s += X[i][k]*X[j][k];
      A[i][j]=s;
    }
    let sy=0;
    for(let k=0;k<n;k++) sy += X[i][k]*y[k];
    B[i]=sy;
  }
  // solve A*c = B (Gaussian elimination)
  const M = A.map((row,i)=>row.concat([B[i]]));
  const m = deg+1;
  for(let i=0;i<m;i++){
    // pivot
    let maxRow=i;
    for(let r=i+1;r<m;r++) if(Math.abs(M[r][i])>Math.abs(M[maxRow][i])) maxRow=r;
    if(Math.abs(M[maxRow][i])<1e-12) return null;
    [M[i],M[maxRow]]=[M[maxRow],M[i]];
    // normalize
    const piv=M[i][i];
    for(let c=i;c<=m;c++) M[i][c]/=piv;
    // eliminate
    for(let r=0;r<m;r++){
      if(r===i) continue;
      const f=M[r][i];
      for(let c=i;c<=m;c++) M[r][c]-=f*M[i][c];
    }
  }
  const coef = M.map(row=>row[m]);
  const yhat = x.map(xx=>{
    let s=0;
    for(let p=0;p<coef.length;p++) s += coef[p]*(xx**p);
    return s;
  });
  const parts = coef.map((c,p)=> p===0 ? `${c.toFixed(4)}` : `${c.toFixed(4)}·t^${p}`);
  return {yhat, desc:`Polinomial grau ${deg}: y = ${parts.join(" + ")}`, r2:r2Score(y,yhat)};
}

function fitExp(x,y){
  // y = a * exp(b t) => ln y = ln a + b t (requires y>0)
  if(y.some(v=>v<=0)) return {error:"Exponencial exige valores > 0 (há zeros/negativos)."};
  const ly = y.map(v=>Math.log(v));
  const lin = fitLinear(x, ly);
  if(!lin) return {error:"Falha no ajuste exponencial."};
  const b = (lin.desc.match(/y = ([\-\d\.]+)/) ? parseFloat(lin.desc.match(/y = ([\-\d\.]+)/)[1]) : null);
  // recompute directly from slope/intercept via standard formula:
  // from fitLinear result: lyhat = slope*t + intercept
  const slope = (()=>{
    // extract slope from yhat= a t + b by recomputing:
    // easier: compute slope using covariance:
    const n=x.length;
    const sx=x.reduce((s,v)=>s+v,0), sy=ly.reduce((s,v)=>s+v,0);
    const sxy=x.reduce((s,v,i)=>s+v*ly[i],0);
    const sxx2=x.reduce((s,v)=>s+v*v,0);
    const denom=(n*sxx2-sx*sx); if(denom===0) return NaN;
    return (n*sxy-sx*sy)/denom;
  })();
  const intercept = (()=>{
    const n=x.length;
    const sx=x.reduce((s,v)=>s+v,0), sy=ly.reduce((s,v)=>s+v,0);
    return (sy - slope*sx)/n;
  })();
  const a = Math.exp(intercept);
  const yhat = x.map(t=> a*Math.exp(slope*t));
  return {yhat, desc:`Exponencial: y = ${a.toFixed(4)}·exp(${slope.toFixed(4)}·t)`, r2:r2Score(y,yhat)};
}

function fitLogistic(x,y){
  // ajuste simples via busca: y = K / (1 + exp(-r (t - t0)))
  // exige y >= 0 e variação significativa
  if(y.some(v=>v<0)) return {error:"Logística exige valores >= 0 (há negativos)."};
  const ymin=Math.min(...y), ymax=Math.max(...y);
  if(ymax - ymin < 1e-9) return {error:"Sem variação suficiente para ajuste logístico."};

  // escolha K ~ 1.05*ymax
  const K = 1.05*ymax;

  // função erro
  const pred = (t,r,t0)=> K/(1+Math.exp(-r*(t-t0)));
  const sse = (r,t0)=>{
    let s=0;
    for(let i=0;i<x.length;i++){
      const yh=pred(x[i],r,t0);
      s += (y[i]-yh)**2;
    }
    return s;
  };

  // grid search leve
  let best={r:0.1,t0:x[Math.floor(x.length/2)], s:Infinity};
  const tMin=Math.min(...x), tMax=Math.max(...x);
  const t0Candidates=Array.from({length:30},(_,i)=> tMin + (tMax-tMin)*i/29);
  const rCandidates=Array.from({length:35},(_,i)=> 0.01 + (1.2-0.01)*i/34);

  for(const t0 of t0Candidates){
    for(const r of rCandidates){
      const s = sse(r,t0);
      if(s<best.s) best={r,t0,s};
    }
  }

  const yhat = x.map(t=>pred(t,best.r,best.t0));
  return {yhat, desc:`Logística: y = ${K.toFixed(4)} / (1 + exp(-${best.r.toFixed(4)}·(t - ${best.t0.toFixed(2)})))`, r2:r2Score(y,yhat)};
}

/* ===========================
   PARSING / LOADING
=========================== */
async function fetchGzText(url){
  const res = await fetch(url, {cache:"no-store"});
  if(!res.ok) throw new Error(`Não consegui carregar: ${url} (${res.status})`);
  const buf = await res.arrayBuffer();
  const u8 = new Uint8Array(buf);
  const inflated = pako.inflate(u8);
  return new TextDecoder("utf-8").decode(inflated);
}

function normalizeRow(r){
  // esperado:
  // scale: "monthly"|"annual"
  // period: "YYYY-MM" ou "YYYY"
  // colunas numéricas das variáveis
  // tolera: Year/Month
  const out = {...r};

  // scale
  if(!out.scale){
    if(out.Scale) out.scale = out.Scale;
  }
  out.scale = String(out.scale||"").toLowerCase().trim();

  // period
  if(!out.period){
    if(out.Period) out.period = out.Period;
    else if(out.date) out.period = out.date;
    else if(out.Year && out.Month) out.period = `${out.Year}-${String(out.Month).padStart(2,"0")}`;
    else if(out.Year) out.period = String(out.Year);
  }
  out.period = String(out.period);

  // year / month
  if(out.scale==="monthly"){
    out.year = Number(out.period.slice(0,4));
    out.month = Number(out.period.slice(5,7));
  } else {
    out.year = Number(out.period.slice(0,4));
    out.month = null;
  }

  // convert numeric
  for(const k of Object.keys(out)){
    if(["scale","period","year","month"].includes(k)) continue;
    const v = out[k];
    if(v===null || v===undefined || v==="") { out[k]=NaN; continue; }
    const num = Number(v);
    out[k] = Number.isFinite(num) ? num : NaN;
  }
  return out;
}

function inferMeta(col){
  // fallback: label bonito do nome da coluna
  const pretty = col
    .replaceAll("_"," ")
    .replaceAll("2m","(2 m)")
    .replace(/\b\w/g, m=>m.toUpperCase());
  return {label: pretty, unit:""};
}

/* ===========================
   FILTERING
=========================== */
function getSelectedMonths(){
  const mode = el("selMonthMode").value;
  if(mode==="all") return null; // null = all
  if(mode==="one"){
    const m = Number(el("selOneMonth").value);
    return [m];
  }
  // many
  const chips = [...document.querySelectorAll(".chip")];
  const ms = chips.filter(c=>c.classList.contains("on")).map(c=>Number(c.dataset.m));
  return ms.length ? ms : null;
}

function filteredRows(){
  const scale = el("selScale").value;
  const v = el("selVar").value;
  const y0 = Number(el("yr0").value);
  const y1 = Number(el("yr1").value);
  const ms = getSelectedMonths();

  const rows = state.raw.filter(r=>{
    if(r.scale!==scale) return false;
    if(!Number.isFinite(r.year)) return false;
    if(r.year<y0 || r.year>y1) return false;
    if(scale==="monthly" && ms && ms.length){
      if(!ms.includes(r.month)) return false;
    }
    return isNum(r[v]);
  });

  return rows;
}

/* ===========================
   PLOTTING
=========================== */
function updateCards(series, unit){
  if(!series.length){
    el("kMin").textContent="—"; el("kMed").textContent="—"; el("kMax").textContent="—";
    el("kMin2").textContent=""; el("kMed2").textContent=""; el("kMax2").textContent="";
    return;
  }
  const vals = series.map(d=>d.y);
  const mn = Math.min(...vals);
  const mx = Math.max(...vals);
  const med = median(vals);

  el("kMin").textContent = `${fmt(mn)} ${unit||""}`.trim();
  el("kMed").textContent = `${fmt(med)} ${unit||""}`.trim();
  el("kMax").textContent = `${fmt(mx)} ${unit||""}`.trim();

  el("kMin2").textContent = `n=${vals.length}`;
  el("kMed2").textContent = `Q1=${fmt(quantile(vals,0.25))} • Q3=${fmt(quantile(vals,0.75))}`;
  el("kMax2").textContent = `amplitude=${fmt(mx-mn)}`;
}

function plotTimeSeries(varName){
  const rows = filteredRows();
  const meta = VAR_META[varName] || inferMeta(varName);
  const unit = meta.unit ? meta.unit : "";
  const scale = el("selScale").value;

  // sort by time
  const series = rows
    .map(r=>({t:r.period, year:r.year, month:r.month, y:r[varName]}))
    .sort((a,b)=> a.t.localeCompare(b.t));

  state.lastFiltered = rows;

  updateCards(series, unit);

  if(!series.length){
    Plotly.newPlot("plot", [], emptyLayout("Sem dados na seleção."));
    return;
  }

  const x = series.map(d=>d.t);
  const y = series.map(d=>d.y);

  const mn = Math.min(...y);
  const mx = Math.max(...y);
  const med = median(y);

  // banda sombreada min-max (horizontal)
  const band = {
    type:"rect",
    xref:"paper", yref:"y",
    x0:0, x1:1,
    y0:mn, y1:mx,
    fillcolor:"rgba(34,197,94,.10)",
    line:{width:0}
  };

  // linhas horizontais
  const shapes = [
    band,
    hline(mn, "rgba(45,108,223,.95)"),
    hline(med,"rgba(239,68,68,.95)"),
    hline(mx, "rgba(34,197,94,.95)")
  ];

  // trace principal
  const trace = {
    type:"scatter",
    mode:"lines+markers",
    x, y,
    name: meta.label,
    line:{width:2},
    marker:{size:5, opacity:.85}
  };

  const annotations = [{
    xref:"paper", x:0.01,
    yref:"paper", y:0.98,
    align:"left",
    text:
      `<b>Min</b> ${fmt(mn)} ${unit} • `+
      `<b>Med</b> ${fmt(med)} ${unit} • `+
      `<b>Max</b> ${fmt(mx)} ${unit}`,
    showarrow:false,
    font:{color:"#EAF0FF", size:12},
    bgcolor:"rgba(0,0,0,.25)",
    bordercolor:"rgba(255,255,255,.10)",
    borderwidth:1
  }];

  // tendência
  const trendMode = el("selTrend").value;
  let trendTrace = null;
  let trendInfo = "";
  if(trendMode!=="none"){
    const t = y.map((_,i)=>i); // tempo como índice (mais estável)
    let fit = null;

    if(trendMode==="linear") fit = fitLinear(t,y);
    if(trendMode==="poly2") fit = polyFit(t,y,2);
    if(trendMode==="poly3") fit = polyFit(t,y,3);
    if(trendMode==="exp")   fit = fitExp(t,y);
    if(trendMode==="logistic") fit = fitLogistic(t,y);

    if(fit && fit.error){
      trendInfo = `⚠️ Tendência não aplicada: ${fit.error}`;
    } else if(fit && fit.yhat){
      trendTrace = {
        type:"scatter",
        mode:"lines",
        x,
        y: fit.yhat,
        name:`Tendência (${trendMode})`,
        line:{width:3, dash:"dot"},
        opacity:0.95
      };
      trendInfo = `${fit.desc}\nR² = ${isNum(fit.r2) ? fit.r2.toFixed(3) : "—"}`;
      annotations.push({
        xref:"paper", x:0.01,
        yref:"paper", y:0.90,
        align:"left",
        text:`<b>Tendência</b><br>${trendInfo.replaceAll("\n","<br>")}`,
        showarrow:false,
        font:{color:"#d7ffe5", size:12},
        bgcolor:"rgba(34,197,94,.10)",
        bordercolor:"rgba(34,197,94,.20)",
        borderwidth:1
      });
    }
  }

  const data = trendTrace ? [trace, trendTrace] : [trace];

  Plotly.newPlot("plot", data, {
    margin:{l:70,r:18,t:50,b:60},
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,.10)",
    title:{text:`Série temporal — ${meta.label} (${unit||"—"})`, font:{color:"#EAF0FF", size:14}},
    xaxis:{
      title: scale==="monthly" ? "Período (YYYY-MM)" : "Ano",
      gridcolor:"rgba(255,255,255,.06)",
      color:"#D7DEEE",
      automargin:true
    },
    yaxis:{
      title:`${meta.label} ${unit?`(${unit})`:""}`,
      gridcolor:"rgba(255,255,255,.08)",
      color:"#D7DEEE",
      automargin:true
    },
    shapes,
    annotations,
    legend:{orientation:"h", y:-0.25, font:{color:"#D7DEEE"}}
  }, {responsive:true, displaylogo:false});
}

function plotBoxplot(varName){
  const scale = el("selScale").value;
  if(scale!=="monthly"){
    Plotly.newPlot("plot", [], emptyLayout("Boxplot é mensal. Troque a escala para Mensal."));
    return;
  }

  const rows = filteredRows();
  const meta = VAR_META[varName] || inferMeta(varName);
  const unit = meta.unit || "";

  // agrupa valores por mês
  const byMonth = Array.from({length:12}, ()=>[]);
  for(const r of rows){
    const v = r[varName];
    if(isNum(v) && r.month>=1 && r.month<=12) byMonth[r.month-1].push(v);
  }

  if(byMonth.every(a=>a.length===0)){
    Plotly.newPlot("plot", [], emptyLayout("Sem dados mensais na seleção."));
    return;
  }

  const traces = byMonth.map((vals,i)=>({
    type:"box",
    y: vals,
    name: MONTHS_PT[i],
    boxpoints:false,              // sem outliers/pontos
    line:{width:2},
    fillcolor: COLORS_MONTH[i],
    marker:{opacity:0.9}
  }));

  Plotly.newPlot("plot", traces, {
    margin:{l:70,r:18,t:50,b:60},
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,.10)",
    title:{text:`Boxplot mensal — ${meta.label} (${unit||"—"})`, font:{color:"#EAF0FF", size:14}},
    xaxis:{
      title:"Mês",
      type:"category",
      categoryorder:"array",
      categoryarray: MONTHS_PT,
      gridcolor:"rgba(255,255,255,.06)",
      color:"#D7DEEE"
    },
    yaxis:{
      title:`${meta.label} ${unit?`(${unit})`:""}`,
      gridcolor:"rgba(255,255,255,.08)",
      color:"#D7DEEE"
    },
    boxmode:"group"
  }, {responsive:true, displaylogo:false});
}

function plotScatter(){
  const scale = el("selScale").value;
  const rows = filteredRows(); // usa o mesmo filtro (ano/mês)
  const xVar = el("selX").value;
  const yVar = el("selY").value;
  const lag = Number(el("selLag").value);

  if(!xVar || !yVar){
    Plotly.newPlot("plot", [], emptyLayout("Escolha as variáveis X e Y."));
    return;
  }

  const mx = VAR_META[xVar] || inferMeta(xVar);
  const my = VAR_META[yVar] || inferMeta(yVar);

  // alinhamento por tempo (period), com lag na Y
  const sorted = rows
    .map(r=>({t:r.period, x:r[xVar], y:r[yVar]}))
    .sort((a,b)=>a.t.localeCompare(b.t));

  const x=[], y=[], t=[];
  for(let i=0;i<sorted.length;i++){
    const j=i+lag;
    if(j>=sorted.length) break;
    const xi=sorted[i].x;
    const yi=sorted[j].y;
    if(isNum(xi) && isNum(yi)){
      x.push(xi); y.push(yi); t.push(sorted[i].t);
    }
  }

  if(x.length<3){
    Plotly.newPlot("plot", [], emptyLayout("Poucos pontos para dispersão com essa seleção/lag."));
    return;
  }

  // regressão linear simples em dispersão
  const tIdx = x.map((_,i)=>i);
  // ajustar y = a*x + b
  // usando fitLinear em x como variável independente (não tempo)
  const fit = (function(){
    const n=x.length;
    const sx=x.reduce((s,v)=>s+v,0);
    const sy=y.reduce((s,v)=>s+v,0);
    const sxy=x.reduce((s,v,i)=>s+v*y[i],0);
    const sxx=x.reduce((s,v)=>s+v*v,0);
    const denom = (n*sxx - sx*sx);
    if(denom===0) return null;
    const a = (n*sxy - sx*sy)/denom;
    const b = (sy - a*sx)/n;
    const yhat = x.map(xx=>a*xx+b);
    const r2 = r2Score(y,yhat);
    return {a,b,yhat,r2};
  })();

  let lineTrace=null, info="";
  if(fit){
    // linha nos extremos de x
    const xmin=Math.min(...x), xmax=Math.max(...x);
    lineTrace = {
      type:"scatter",
      mode:"lines",
      x:[xmin,xmax],
      y:[fit.a*xmin+fit.b, fit.a*xmax+fit.b],
      name:"Regressão linear",
      line:{width:3, dash:"dot"},
      opacity:0.95
    };
    info = `y = ${fit.a.toFixed(4)}·x + ${fit.b.toFixed(4)} • R²=${isNum(fit.r2)?fit.r2.toFixed(3):"—"}`;
  }

  const trace = {
    type:"scatter",
    mode:"markers",
    x, y,
    text: t,
    hovertemplate: "%{text}<br><b>X</b>: %{x:.3f}<br><b>Y</b>: %{y:.3f}<extra></extra>",
    name:"Pontos",
    marker:{size:7, opacity:0.85}
  };

  const data = lineTrace ? [trace, lineTrace] : [trace];

  Plotly.newPlot("plot", data, {
    margin:{l:70,r:18,t:50,b:60},
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,.10)",
    title:{text:`Dispersão — ${mx.label} vs ${my.label} (lag Y = ${lag})`, font:{color:"#EAF0FF", size:14}},
    xaxis:{title:`${mx.label} ${mx.unit?`(${mx.unit})`:""}`, gridcolor:"rgba(255,255,255,.06)", color:"#D7DEEE"},
    yaxis:{title:`${my.label} ${my.unit?`(${my.unit})`:""}`, gridcolor:"rgba(255,255,255,.08)", color:"#D7DEEE"},
    annotations: info ? [{
      xref:"paper", x:0.01,
      yref:"paper", y:0.98,
      text:`<b>Regressão</b><br>${info}`,
      showarrow:false,
      align:"left",
      font:{color:"#EAF0FF", size:12},
      bgcolor:"rgba(0,0,0,.25)",
      bordercolor:"rgba(255,255,255,.10)",
      borderwidth:1
    }] : []
  }, {responsive:true, displaylogo:false});
}

function plotTable(varName){
  const rows = filteredRows()
    .map(r=>{
      const o = {scale:r.scale, period:r.period, year:r.year};
      if(r.month) o.month=r.month;
      o[varName]=r[varName];
      return o;
    })
    .sort((a,b)=> String(a.period).localeCompare(String(b.period)));

  if(!rows.length){
    Plotly.newPlot("plot", [], emptyLayout("Sem dados na seleção."));
    return;
  }

  const meta = VAR_META[varName] || inferMeta(varName);

  const header = Object.keys(rows[0]);
  const cells = header.map(h=>rows.map(r=>r[h]));

  Plotly.newPlot("plot", [{
    type:"table",
    header:{
      values: header.map(h=>`<b>${h}</b>`),
      fill:{color:"rgba(45,108,223,.15)"},
      font:{color:"#EAF0FF", size:12},
      align:"left"
    },
    cells:{
      values: cells,
      fill:{color:"rgba(0,0,0,.20)"},
      font:{color:"#D7DEEE", size:12},
      align:"left"
    }
  }], {
    margin:{l:10,r:10,t:45,b:10},
    paper_bgcolor:"rgba(0,0,0,0)",
    title:{text:`Tabela — ${meta.label}`, font:{color:"#EAF0FF", size:14}}
  }, {responsive:true, displaylogo:false});
}

function emptyLayout(msg){
  return {
    margin:{l:40,r:20,t:40,b:40},
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,.10)",
    xaxis:{visible:false},
    yaxis:{visible:false},
    annotations:[{
      xref:"paper", yref:"paper", x:0.5, y:0.5,
      text:`<b>${msg}</b>`,
      showarrow:false,
      font:{color:"#EAF0FF", size:14},
      bgcolor:"rgba(0,0,0,.25)",
      bordercolor:"rgba(255,255,255,.10)",
      borderwidth:1,
      borderpad:10
    }]
  };
}
function hline(y, color){
  return {
    type:"line",
    xref:"paper", x0:0, x1:1,
    yref:"y", y0:y, y1:y,
    line:{color:color, width:2, dash:"dash"}
  };
}

/* ===========================
   UI BUILD
=========================== */
function buildMonthSelectors(){
  // one month
  el("selOneMonth").innerHTML = MONTHS_PT.map((m,i)=>`<option value="${i+1}">${m}</option>`).join("");

  // chips for many
  const chips = el("monthChips");
  chips.innerHTML = "";
  MONTHS_PT.forEach((m,i)=>{
    const c=document.createElement("div");
    c.className="chip";
    c.textContent=m;
    c.dataset.m=String(i+1);
    c.onclick=()=>{
      c.classList.toggle("on");
      recalc();
    };
    chips.appendChild(c);
  });
}

function buildLag(){
  const sel = el("selLag");
  sel.innerHTML = "";
  for(let i=0;i<=12;i++){
    const opt=document.createElement("option");
    opt.value=String(i);
    opt.textContent=String(i);
    sel.appendChild(opt);
  }
}

function buildVarSelects(){
  const numericCols = state.cols.filter(c=>!["scale","period","year","month"].includes(c));
  // update meta fallback
  for(const c of numericCols){
    if(!VAR_META[c]) VAR_META[c]=inferMeta(c);
  }

  const opts = numericCols.map(c=>`<option value="${c}">${VAR_META[c].label}${VAR_META[c].unit?` (${VAR_META[c].unit})`:""}</option>`).join("");

  el("selVar").innerHTML = opts;
  el("selX").innerHTML = opts;
  el("selY").innerHTML = opts;

  // defaults
  const def = numericCols.includes("temperature_2m") ? "temperature_2m" : numericCols[0];
  el("selVar").value = def;
  el("selX").value = numericCols.includes("temperature_2m") ? "temperature_2m" : numericCols[0];
  el("selY").value = numericCols.includes("precipitation") ? "precipitation" : (numericCols[1]||numericCols[0]);

  updateVarDescription();
}

function updateVarDescription(){
  const v = el("selVar").value;
  const meta = VAR_META[v] || inferMeta(v);

  // texto “leigo + técnico”
  const meaning = {
    precipitation: "Chuva é o principal motor do ciclo hidrológico. Afeta abastecimento, drenagem urbana, agricultura e risco de incêndios.",
    temperature_2m: "Temperatura do ar influencia conforto térmico, saúde, demanda energética, evaporação e estresse em cultivos.",
    dewpoint_2m: "Ponto de orvalho indica quanta umidade há no ar. Ajuda a entender sensação térmica e potencial de formação de nuvens/neblina.",
    relative_humidity_2m: "Umidade relativa modula estresse térmico humano, risco de queimadas e perdas por evaporação.",
    surface_solar_radiation: "Radiação solar controla aquecimento da superfície, evapotranspiração e produtividade vegetal.",
    net_solar_radiation: "Radiação líquida é energia disponível para aquecer ar/solo e evaporar água—indicador-chave de secura e demanda evaporativa.",
    soil_moisture_layer1: "Umidade superficial do solo responde rápido à chuva e seca. Importante para agricultura e risco de fogo.",
    soil_moisture_layer2: "Umidade em camada mais profunda indica reserva hídrica e resiliência à seca.",
    evap_canopy: "Evaporação no dossel reflete interceptação da chuva e perda de água pelas folhas.",
    evap_soil: "Evaporação direta do solo cresce em períodos secos e com alta radiação/vento.",
    evap_total: "Evapotranspiração integra perdas de água do solo e vegetação—boa para gestão hídrica e agricultura.",
    wind_speed_10m: "Vento aumenta evaporação e espalhamento de fumaça/fogo; afeta conforto e eventos extremos."
  }[v] || "Indicador climático relevante para diagnóstico local e apoio a políticas públicas. Use tendências e comparações para interpretar mudanças ao longo do tempo.";

  el("status").className="status";
  el("status").textContent =
`Variável: ${meta.label}${meta.unit?` (${meta.unit})`:""}
Significado: ${meaning}

Dica: use “Tendência” para comunicar mudança climática e “Boxplot” para variabilidade sazonal.`;
}

/* ===========================
   RECALC / TAB ROUTER
=========================== */
function recalc(){
  if(!state.ready) return;
  updateVarDescription();
  const v = el("selVar").value;

  if(state.tab==="ts") plotTimeSeries(v);
  if(state.tab==="box") plotBoxplot(v);
  if(state.tab==="scat") plotScatter();
  if(state.tab==="tbl") plotTable(v);
}

function setTab(tab){
  state.tab = tab;
  document.querySelectorAll(".tab").forEach(t=>t.classList.toggle("on", t.dataset.tab===tab));
  recalc();
}

/* ===========================
   EXPORTS
=========================== */
function exportSelectionCSV(){
  const v = el("selVar").value;
  const rows = filteredRows()
    .map(r=>{
      const out = {scale:r.scale, period:r.period, year:r.year};
      if(r.month) out.month=r.month;
      for(const c of state.cols){
        if(["scale","period","year","month"].includes(c)) continue;
        out[c]=r[c];
      }
      return out;
    })
    .sort((a,b)=> String(a.period).localeCompare(String(b.period)));

  if(!rows.length){
    alert("Sem dados para exportar (ajuste filtros).");
    return;
  }

  const csv = Papa.unparse(rows);
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `PLAC_Caceres_selecao_${el("selScale").value}_${new Date().toISOString().slice(0,10)}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

async function savePNG(){
  try{
    await Plotly.downloadImage("plot", {format:"png", filename:"PLAC_Caceres_grafico", height:720, width:1100});
  }catch(e){
    alert("Falha ao salvar PNG: "+e.message);
  }
}

/* ===========================
   INIT
=========================== */
function wireUI(){
  buildMonthSelectors();
  buildLag();

  el("selScale").addEventListener("change", ()=>{
    // habilita/desabilita meses
    const scale = el("selScale").value;
    const mm = el("selMonthMode");
    if(scale==="annual"){
      mm.value="all";
      mm.disabled=true;
      el("selOneMonth").disabled=true;
      el("monthChips").style.opacity=.55;
      el("monthChips").style.pointerEvents="none";
    }else{
      mm.disabled=false;
      // aplica modo atual
      onMonthMode();
    }
    recalc();
  });

  el("selVar").addEventListener("change", recalc);
  el("yr0").addEventListener("change", recalc);
  el("yr1").addEventListener("change", recalc);
  el("selTrend").addEventListener("change", recalc);
  el("selX").addEventListener("change", recalc);
  el("selY").addEventListener("change", recalc);
  el("selLag").addEventListener("change", recalc);

  el("selMonthMode").addEventListener("change", ()=>{
    onMonthMode();
    recalc();
  });
  el("selOneMonth").addEventListener("change", recalc);

  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", ()=>setTab(t.dataset.tab));
  });

  el("btnCSV").addEventListener("click", exportSelectionCSV);
  el("btnPNG").addEventListener("click", savePNG);
  el("btnReset").addEventListener("click", ()=>{
    // reset filtros básicos
    el("selScale").value="monthly";
    el("selMonthMode").value="all";
    onMonthMode();
    el("selTrend").value="none";
    // anos default
    const yrs = state.raw.map(r=>r.year).filter(Number.isFinite);
    el("yr0").value = Math.min(...yrs);
    el("yr1").value = Math.max(...yrs);
    // variável default
    const numericCols = state.cols.filter(c=>!["scale","period","year","month"].includes(c));
    el("selVar").value = numericCols.includes("temperature_2m") ? "temperature_2m" : numericCols[0];
    recalc();
  });
}

function onMonthMode(){
  const mode = el("selMonthMode").value;
  const one = el("selOneMonth");
  const chips = el("monthChips");

  if(mode==="all"){
    one.disabled=true;
    chips.style.opacity=.55;
    chips.style.pointerEvents="none";
    // desliga chips
    [...chips.querySelectorAll(".chip")].forEach(c=>c.classList.remove("on"));
  }
  if(mode==="one"){
    one.disabled=false;
    chips.style.opacity=.55;
    chips.style.pointerEvents="none";
    [...chips.querySelectorAll(".chip")].forEach(c=>c.classList.remove("on"));
  }
  if(mode==="many"){
    one.disabled=true;
    chips.style.opacity=1;
    chips.style.pointerEvents="auto";
  }
}

async function init(){
  wireUI();

  el("status").className="status";
  el("status").textContent = "Carregando dados compactados…\nArquivo esperado: "+DATA_URL;

  try{
    const text = await fetchGzText(DATA_URL);
    const parsed = Papa.parse(text, {header:true, dynamicTyping:false, skipEmptyLines:true});
    if(parsed.errors?.length){
      console.warn(parsed.errors);
    }

    const rows = parsed.data.map(normalizeRow);

    // cols
    const cols = Object.keys(rows[0]||{});
    // garante colunas essenciais
    for(const c of ["scale","period","year","month"]) if(!cols.includes(c)) cols.push(c);

    state.raw = rows;
    state.cols = cols;
    state.ready = true;

    // anos default
    const yrs = rows.map(r=>r.year).filter(Number.isFinite);
    const yMin = Math.min(...yrs);
    const yMax = Math.max(...yrs);
    el("yr0").value = yMin;
    el("yr1").value = yMax;

    // escala default
    el("selScale").value="monthly";
    el("selMonthMode").value="all";
    onMonthMode();

    buildVarSelects();

    el("status").className="status ok";
    el("status").textContent =
`Dados carregados com sucesso.
Período disponível: ${yMin} – ${yMax}
Linhas: ${rows.length}
Arquivo: ${DATA_URL}

Organizador: Ernandes Sobreira Oliveira Junior (uso educacional e políticas públicas).`;

    // primeiro plot
    recalc();

  }catch(err){
    console.error(err);
    el("status").className="status bad";
    el("status").textContent =
`ERRO ao carregar dados.
${err.message}

Verifique:
1) O arquivo existe em ${DATA_URL}
2) O nome bate 100% (maiúsculas/minúsculas)
3) Você publicou no GitHub Pages e aguardou atualizar.`;
    Plotly.newPlot("plot", [], emptyLayout("Não consegui carregar os dados. Veja o painel à esquerda."));
  }
}

init();
</script>
</body>
</html>
