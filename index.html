<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PLAC Cáceres — Painel Climático (Mensal/Anual)</title>

  <!-- Libs -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

  <style>
    :root{
      --bg0:#06121a;
      --bg1:#0b1c2b;
      --card:rgba(255,255,255,.08);
      --card2:rgba(255,255,255,.06);
      --line:rgba(255,255,255,.12);
      --text:#eaf2ff;
      --muted:#b6c6dd;

      /* RGB vibe */
      --r:#ff3b3b;
      --g:#14ff7a;
      --b:#2aa8ff;

      --shadow: 0 22px 60px rgba(0,0,0,.55);
      --rds:18px;
      --rds2:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    html,body{height:100%;}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 900px at 15% 20%, rgba(42,168,255,.20), transparent 55%),
        radial-gradient(900px 700px at 85% 25%, rgba(20,255,122,.16), transparent 60%),
        radial-gradient(900px 700px at 70% 85%, rgba(255,59,59,.16), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
    }

    .topbar{
      position:sticky; top:0; z-index:10;
      background: linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.20));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }

    .topbar-inner{
      max-width:1200px;
      margin:0 auto;
      padding:14px 14px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }

    .brand{
      display:flex; align-items:center; gap:10px;
      min-width: 280px;
    }
    .logo{
      width:38px;height:38px;border-radius:12px;
      background: conic-gradient(from 180deg, var(--r), var(--g), var(--b), var(--r));
      box-shadow: 0 10px 30px rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.18);
    }
    .title-wrap{line-height:1.1}
    .title{font-weight:800; letter-spacing:.2px;}
    .subtitle{font-size:12px;color:var(--muted); margin-top:3px}

    .actions{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;}
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:700;
      transition:.15s transform, .15s background, .15s border;
      box-shadow: 0 12px 28px rgba(0,0,0,.30);
    }
    .btn:hover{transform: translateY(-1px); border-color: rgba(255,255,255,.26);}
    .btn:active{transform: translateY(0px) scale(.99);}

    .btn.r{background: linear-gradient(180deg, rgba(255,59,59,.22), rgba(255,59,59,.08)); border-color: rgba(255,59,59,.35);}
    .btn.g{background: linear-gradient(180deg, rgba(20,255,122,.20), rgba(20,255,122,.07)); border-color: rgba(20,255,122,.30);}
    .btn.b{background: linear-gradient(180deg, rgba(42,168,255,.22), rgba(42,168,255,.08)); border-color: rgba(42,168,255,.35);}

    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:18px 14px 30px;
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr;}
      .brand{min-width:unset;}
    }

    .panel{
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--rds);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panel .hd{
      padding:12px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.04);
      font-weight:800;
    }
    .panel .bd{padding:12px;}

    .note{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding:10px 10px;
      color:var(--muted);
      font-size:12px;
      line-height:1.35;
    }
    .note strong{color:var(--text);}

    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
    .grid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px;}

    label{display:block; font-size:12px; color:var(--muted); margin:10px 0 6px}
    select, input{
      width:100%;
      padding:10px 10px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color:var(--text);
      outline:none;
    }
    select:focus,input:focus{border-color: rgba(42,168,255,.50);}

    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding:8px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size:12px;
      color:var(--muted);
    }
    .dot{width:9px;height:9px;border-radius:50%;}
    .dot.r{background:var(--r)} .dot.g{background:var(--g)} .dot.b{background:var(--b)}

    .cards{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .card{
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding:10px;
    }
    .card .k{font-size:12px; color:var(--muted)}
    .card .v{font-size:16px; font-weight:900; margin-top:6px}
    .tiny{font-size:12px;color:var(--muted); margin-top:6px}
    .err{
      margin-top:10px;
      padding:10px;
      border-radius:14px;
      border:1px solid rgba(255,59,59,.35);
      background: rgba(255,59,59,.10);
      color: #ffd1d1;
      font-size:12px;
      display:none;
      white-space:pre-wrap;
    }

    .tabs{
      display:flex; gap:8px; flex-wrap:wrap;
      padding:10px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
    }
    .tab{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color:var(--text);
      padding:8px 10px;
      border-radius: 999px;
      font-weight:800;
      cursor:pointer;
      font-size:12px;
    }
    .tab.active{
      border-color: rgba(42,168,255,.55);
      background: rgba(42,168,255,.12);
    }
    .view{display:none; padding:10px;}
    .view.active{display:block;}
    .plot{height:520px;}
    @media (max-width: 980px){ .plot{height:480px;} }

    .progress{
      margin-top:10px;
      height:10px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.10);
    }
    .bar{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, var(--b), var(--g), var(--r));
      transition: width .25s ease;
    }

    table{width:100%; border-collapse: collapse; font-size:12px;}
    th,td{border-bottom:1px solid rgba(255,255,255,.10); padding:8px 6px; text-align:left;}
    th{color:var(--muted); font-weight:800;}
    td{color:var(--text);}
    .mono{font-family:var(--mono);}
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="logo"></div>
        <div class="title-wrap">
          <div class="title">PLAC Cáceres — Painel Climático (Mensal/Anual)</div>
          <div class="subtitle">Dados + estatística + gráficos claros para decisão pública (Cáceres/MT)</div>
        </div>
      </div>

      <div class="actions">
        <button class="btn b" id="btnSavePng">Salvar gráfico (PNG)</button>
        <button class="btn g" id="btnExportCsv">Exportar seleção (CSV)</button>
        <button class="btn r" id="btnReset">Reset</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <!-- CONTROLES -->
    <div class="panel">
      <div class="hd">Controles — Cáceres (MT)</div>
      <div class="bd">

        <div class="note">
          <strong>Objetivo:</strong> permitir que qualquer pessoa (leiga ou técnica) veja <strong>tendência</strong>,
          <strong>sazonalidade</strong>, <strong>variabilidade</strong> e <strong>relações entre variáveis</strong>,
          com estatística transparente e exportável.<br><br>
          <strong>Organizador:</strong> Ernandes Sobreira Oliveira Junior (uso educacional e políticas públicas).
        </div>

        <label>Escala</label>
        <select id="selScale">
          <option value="monthly">Mensal</option>
          <option value="annual">Anual</option>
        </select>

        <label>Variável (indicador)</label>
        <select id="selVar"></select>

        <div class="grid2">
          <div>
            <label>Ano (início)</label>
            <input id="yearStart" type="number" placeholder="ex: 1981">
          </div>
          <div>
            <label>Ano (fim)</label>
            <input id="yearEnd" type="number" placeholder="ex: 2026">
          </div>
        </div>

        <label>Meses (apenas para escala mensal)</label>
        <div class="grid2">
          <select id="selMonthA">
            <option value="all">Todos os meses</option>
            <option value="1">Jan</option><option value="2">Fev</option><option value="3">Mar</option><option value="4">Abr</option>
            <option value="5">Mai</option><option value="6">Jun</option><option value="7">Jul</option><option value="8">Ago</option>
            <option value="9">Set</option><option value="10">Out</option><option value="11">Nov</option><option value="12">Dez</option>
          </select>
          <select id="selMonthB">
            <option value="all">—</option>
            <option value="1">Jan</option><option value="2">Fev</option><option value="3">Mar</option><option value="4">Abr</option>
            <option value="5">Mai</option><option value="6">Jun</option><option value="7">Jul</option><option value="8">Ago</option>
            <option value="9">Set</option><option value="10">Out</option><option value="11">Nov</option><option value="12">Dez</option>
          </select>
        </div>

        <div class="grid2">
          <div>
            <label>Tendência (modelo)</label>
            <select id="selTrend">
              <option value="none">Sem tendência</option>
              <option value="linear">Linear</option>
              <option value="poly2">Polinomial (2º)</option>
              <option value="poly3">Polinomial (3º)</option>
              <option value="exp">Exponencial</option>
              <option value="logistic">Logística</option>
            </select>
          </div>
          <div>
            <label>Defasagem (lag) p/ dispersão</label>
            <select id="selLag">
              <option value="0">0</option>
              <option value="1">1</option><option value="2">2</option><option value="3">3</option>
              <option value="6">6</option><option value="12">12</option>
            </select>
          </div>
        </div>

        <div class="cards">
          <div class="card"><div class="k">Média</div><div class="v" id="kMean">—</div></div>
          <div class="card"><div class="k">Mediana</div><div class="v" id="kMedian">—</div></div>
          <div class="card"><div class="k">Mínimo</div><div class="v" id="kMin">—</div></div>
          <div class="card"><div class="k">Máximo</div><div class="v" id="kMax">—</div></div>
        </div>

        <div class="tiny" id="trendInfo"></div>

        <div class="progress"><div class="bar" id="bar"></div></div>
        <div class="err" id="errBox"></div>

        <label>Dispersão (comparar 2 variáveis)</label>
        <div class="grid2">
          <select id="selX"></select>
          <select id="selY"></select>
        </div>

        <div class="tiny">
          <span class="pill"><span class="dot b"></span> Série: média</span>
          <span class="pill"><span class="dot g"></span> Min/Max + faixa</span>
          <span class="pill"><span class="dot r"></span> Tendência</span>
        </div>
      </div>
    </div>

    <!-- VIEWS -->
    <div class="panel">
      <div class="tabs">
        <button class="tab active" data-view="vSeries">Série temporal</button>
        <button class="tab" data-view="vBox">Boxplot (meses)</button>
        <button class="tab" data-view="vScatter">Dispersão + regressão</button>
        <button class="tab" data-view="vTable">Tabela</button>
      </div>

      <div class="view active" id="vSeries">
        <div id="plotSeries" class="plot"></div>
      </div>

      <div class="view" id="vBox">
        <div id="plotBox" class="plot"></div>
      </div>

      <div class="view" id="vScatter">
        <div id="plotScatter" class="plot"></div>
      </div>

      <div class="view" id="vTable">
        <div style="overflow:auto; max-height:560px;">
          <table id="tbl"></table>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================
   CONFIG
========================= */
const DATA_URL = "data/caceres_keyvars_monthly_annual.csv.gz";

/* =========================
   HELPERS (robustos)
========================= */
const months = [
  {n:1, lab:"Jan"},{n:2, lab:"Fev"},{n:3, lab:"Mar"},{n:4, lab:"Abr"},
  {n:5, lab:"Mai"},{n:6, lab:"Jun"},{n:7, lab:"Jul"},{n:8, lab:"Ago"},
  {n:9, lab:"Set"},{n:10,lab:"Out"},{n:11,lab:"Nov"},{n:12,lab:"Dez"}
];

function setErr(msg){
  const el = document.getElementById("errBox");
  if(!msg){ el.style.display="none"; el.textContent=""; return; }
  el.style.display="block";
  el.textContent = msg;
}
function setBar(p){ document.getElementById("bar").style.width = Math.max(0,Math.min(100,p))+"%"; }

function detectDelimiter(sampleText){
  const line = sampleText.split(/\r?\n/).find(l=>l.trim().length>0) || "";
  const cComma = (line.match(/,/g)||[]).length;
  const cSemi  = (line.match(/;/g)||[]).length;
  const cTab   = (line.match(/\t/g)||[]).length;
  if(cSemi>=cComma && cSemi>=cTab) return ";";
  if(cTab>=cComma && cTab>=cSemi) return "\t";
  return ",";
}

function toNumberSmart(v){
  if(v===null || v===undefined) return NaN;
  if(typeof v === "number") return v;
  let s = String(v).trim();
  if(!s) return NaN;
  s = s.replace(/^\uFEFF/, "");
  // decimal BR
  if(s.includes(",") && !s.includes(".")) s = s.replace(",", ".");
  s = s.replace(/\s+/g, "");
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}

function normalizeRow(r){
  const out = {};
  for(const k of Object.keys(r)){
    const kk = String(k).replace(/^\uFEFF/, "").trim();
    out[kk] = r[k];
  }

  // required: scale + period
  if(!out.scale){
    if(out.Scale) out.scale = out.Scale;
    if(out.escala) out.scale = out.escala;
    if(out.Escala) out.scale = out.Escala;
  }
  out.scale = String(out.scale||"").toLowerCase().trim();

  if(!out.period){
    if(out.Period) out.period = out.Period;
    else if(out.periodo) out.period = out.periodo;
    else if(out["Período"]) out.period = out["Período"];
    else if(out.date) out.period = out.date;
    else if(out.Year && out.Month) out.period = `${out.Year}-${String(out.Month).padStart(2,"0")}`;
    else if(out.Ano && out.Mes) out.period = `${out.Ano}-${String(out.Mes).padStart(2,"0")}`;
    else if(out.Year) out.period = String(out.Year);
    else if(out.Ano) out.period = String(out.Ano);
  }
  out.period = String(out.period||"").trim();

  if(out.scale==="monthly"){
    out.year = toNumberSmart(out.period.slice(0,4));
    out.month = toNumberSmart(out.period.slice(5,7));
  } else {
    out.year = toNumberSmart(out.period.slice(0,4));
    out.month = null;
  }

  for(const k of Object.keys(out)){
    if(["scale","period","year","month"].includes(k)) continue;
    out[k] = toNumberSmart(out[k]);
  }
  return out;
}

function median(arr){
  const a = arr.filter(Number.isFinite).slice().sort((x,y)=>x-y);
  if(!a.length) return NaN;
  const m = Math.floor(a.length/2);
  return a.length%2 ? a[m] : (a[m-1]+a[m])/2;
}
function mean(arr){
  const a = arr.filter(Number.isFinite);
  if(!a.length) return NaN;
  return a.reduce((s,v)=>s+v,0)/a.length;
}
function qtile(arr, q){
  const a = arr.filter(Number.isFinite).slice().sort((x,y)=>x-y);
  if(!a.length) return NaN;
  const pos = (a.length-1)*q;
  const base = Math.floor(pos);
  const rest = pos-base;
  if(a[base+1]===undefined) return a[base];
  return a[base] + rest*(a[base+1]-a[base]);
}
function fmt(v, digits=2){
  if(!Number.isFinite(v)) return "—";
  return v.toLocaleString("pt-BR",{maximumFractionDigits:digits});
}
function monthLabel(m){ return months.find(x=>x.n===m)?.lab || String(m); }

/* =========================
   VARIABLE META (descrições)
========================= */
const VAR_META = {
  precipitation: {name:"Precipitação", unit:"mm", desc:"Chuva acumulada. Base para cheias/secas, agricultura, abastecimento e risco de fogo."},
  temperature_2m: {name:"Temperatura do ar (2m)", unit:"°C", desc:"Temperatura próxima à superfície. Relevante para estresse térmico, saúde, energia e agricultura."},
  dewpoint_2m: {name:"Ponto de orvalho (2m)", unit:"°C", desc:"Medida de umidade do ar. Ajuda a entender desconforto térmico, formação de neblina e risco de secura."},
  relative_humidity_2m: {name:"Umidade relativa (2m)", unit:"%", desc:"Umidade do ar. Impacta saúde respiratória, conforto, risco de fogo e secagem do solo."},
  surface_solar_radiation_downwards: {name:"Radiação solar (entrada)", unit:"MJ/m²", desc:"Energia solar que chega à superfície. Afeta evaporação, temperatura e demanda hídrica."},
  net_solar_radiation: {name:"Radiação solar líquida", unit:"MJ/m²", desc:"Saldo de energia solar. Direciona aquecimento e evapotranspiração."},
  evaporation_from_vegetation_transpiration: {name:"Transpiração da vegetação", unit:"mm", desc:"Perda de água por plantas. Indica estresse hídrico e dinâmica do ecossistema."},
  evaporation_from_bare_soil: {name:"Evaporação do solo exposto", unit:"mm", desc:"Perda de água direta do solo. Importante para secas e risco de fogo."},
  total_evaporation: {name:"Evaporação total", unit:"mm", desc:"Soma das perdas por evaporação/transpiração. Indica demanda atmosférica por água."},
  volumetric_soil_water_layer_1: {name:"Umidade do solo (camada 1)", unit:"m³/m³", desc:"Água no solo superficial. Responde rápido à chuva e influencia vegetação e fogo."},
  soil_temperature_level_1: {name:"Temperatura do solo (nível 1)", unit:"°C", desc:"Aquecimento do solo. Afeta germinação, microbiota, evaporação e estresse hídrico."},
  runoff: {name:"Escoamento superficial", unit:"mm", desc:"Água que escoa na superfície. Relaciona-se a enchentes, erosão e recarga."},
};

/* =========================
   STATE
========================= */
const state = {
  rows: [],          // all rows normalized
  vars: [],          // variable columns
  scale: "monthly",
  var: null,
  x: null,
  y: null,
  lag: 0,
  monthA: "all",
  monthB: "all",
  yearStart: null,
  yearEnd: null,
  trend: "none",
};

/* =========================
   LOAD DATA
========================= */
async function loadGzCsv(url){
  setErr("");
  setBar(5);

  const res = await fetch(url, {cache:"no-store"});
  if(!res.ok) throw new Error(`Não consegui carregar: ${url} (${res.status})`);

  setBar(20);
  const ab = await res.arrayBuffer();
  setBar(35);

  const u8 = new Uint8Array(ab);
  const txt = new TextDecoder("utf-8").decode(pako.ungzip(u8));
  setBar(55);

  const delim = detectDelimiter(txt.slice(0, 8000));
  const parsed = Papa.parse(txt, {
    header:true,
    skipEmptyLines:true,
    delimiter: delim,
    transformHeader: h => String(h).replace(/^\uFEFF/,"").trim(),
    transform: v => (typeof v === "string" ? v.trim() : v)
  });
  if(parsed.errors?.length){
    console.warn(parsed.errors);
  }

  setBar(70);
  const rows = parsed.data.map(normalizeRow).filter(r => r.scale && r.period);

  // infer vars: numeric columns (excluding known)
  const sample = rows[0] || {};
  const keys = Object.keys(sample).filter(k => !["scale","period","year","month"].includes(k));
  const vars = keys.filter(k => rows.some(r => Number.isFinite(r[k])));

  setBar(85);
  return {rows, vars};
}

/* =========================
   FILTERS
========================= */
function getSelectionRows(){
  const sc = state.scale;
  let a = state.rows.filter(r => r.scale === sc);

  // years
  const ys = toNumberSmart(document.getElementById("yearStart").value);
  const ye = toNumberSmart(document.getElementById("yearEnd").value);
  const hasYS = Number.isFinite(ys);
  const hasYE = Number.isFinite(ye);
  if(hasYS) a = a.filter(r => r.year >= ys);
  if(hasYE) a = a.filter(r => r.year <= ye);

  // month filter (monthly only)
  if(sc==="monthly"){
    const mA = document.getElementById("selMonthA").value;
    const mB = document.getElementById("selMonthB").value;

    if(mA !== "all"){
      const mi = Number(mA);
      if(mB !== "all"){
        const mj = Number(mB);
        const lo = Math.min(mi,mj), hi = Math.max(mi,mj);
        a = a.filter(r => r.month>=lo && r.month<=hi);
      } else {
        a = a.filter(r => r.month===mi);
      }
    }
  }
  return a;
}

/* =========================
   MODELS (trend)
========================= */
function linreg(x,y){
  const n = x.length;
  let sx=0, sy=0, sxx=0, sxy=0;
  for(let i=0;i<n;i++){
    sx+=x[i]; sy+=y[i]; sxx+=x[i]*x[i]; sxy+=x[i]*y[i];
  }
  const denom = (n*sxx - sx*sx);
  const b = denom===0 ? 0 : (n*sxy - sx*sy)/denom;
  const a = (sy - b*sx)/n;
  return {a,b};
}
function r2Score(y, yhat){
  const a = y.filter(Number.isFinite);
  if(!a.length) return NaN;
  const mu = mean(a);
  let ssTot=0, ssRes=0;
  for(let i=0;i<y.length;i++){
    const yi=y[i], yh=yhat[i];
    if(!Number.isFinite(yi) || !Number.isFinite(yh)) continue;
    ssTot += (yi-mu)*(yi-mu);
    ssRes += (yi-yh)*(yi-yh);
  }
  return ssTot===0 ? NaN : (1 - ssRes/ssTot);
}
function polyFit(x, y, deg){
  // normal equations (small deg only)
  const n = x.length;
  const X = Array.from({length:deg+1}, ()=>Array(deg+1).fill(0));
  const Y = Array(deg+1).fill(0);

  for(let i=0;i<n;i++){
    let xp = 1;
    const xs = [];
    for(let d=0; d<=deg*2; d++){
      xs[d] = (d===0?1: xs[d-1]*x[i]);
    }
    for(let r=0;r<=deg;r++){
      for(let c=0;c<=deg;c++){
        X[r][c] += xs[r+c];
      }
      Y[r] += y[i]*xs[r];
    }
  }
  // gaussian elimination
  const A = X.map((row,i)=>row.concat([Y[i]]));
  for(let i=0;i<=deg;i++){
    // pivot
    let piv=i;
    for(let r=i+1;r<=deg;r++){
      if(Math.abs(A[r][i])>Math.abs(A[piv][i])) piv=r;
    }
    [A[i],A[piv]]=[A[piv],A[i]];
    const div = A[i][i] || 1e-12;
    for(let c=i;c<=deg+1;c++) A[i][c]/=div;
    for(let r=0;r<=deg;r++){
      if(r===i) continue;
      const f = A[r][i];
      for(let c=i;c<=deg+1;c++) A[r][c]-=f*A[i][c];
    }
  }
  const coef = A.map(row=>row[deg+1]); // a0..adeg
  return coef;
}
function polyEval(coef, x){
  return x.map(v=>{
    let s=0, p=1;
    for(let i=0;i<coef.length;i++){
      s += coef[i]*p;
      p *= v;
    }
    return s;
  });
}

function expFit(x,y){
  // y = A*exp(Bx) -> ln y = lnA + Bx (need y>0)
  const xx=[], yy=[];
  for(let i=0;i<x.length;i++){
    if(y[i]>0){
      xx.push(x[i]);
      yy.push(Math.log(y[i]));
    }
  }
  if(xx.length<3) return null;
  const {a,b} = linreg(xx,yy);
  const A = Math.exp(a), B = b;
  return {A,B};
}
function expEval(model, x){
  return x.map(v => model.A*Math.exp(model.B*v));
}

function logisticEval(params, x){
  const {L,k,x0} = params;
  return x.map(v => L/(1+Math.exp(-k*(v-x0))));
}
function logisticFitSimple(x,y){
  // Heurística estável (não é “ótimo global”), mas funciona bem em séries climáticas suaves:
  // L ~ max(y), x0 ~ mediana(x), k ~ ajustado por regressão na transformação logit com clipping.
  const yy = y.filter(Number.isFinite);
  if(yy.length<6) return null;
  const L = Math.max(...yy);
  const x0 = median(x);
  // build transformed: z = ln(y/(L-y))
  const xx=[], zz=[];
  for(let i=0;i<x.length;i++){
    const yi=y[i];
    if(!Number.isFinite(yi)) continue;
    const eps = 1e-6;
    const yc = Math.min(L-eps, Math.max(eps, yi));
    const z = Math.log(yc/(L-yc));
    if(Number.isFinite(z)){
      xx.push(x[i]);
      zz.push(z);
    }
  }
  if(xx.length<6) return null;
  const {a,b} = linreg(xx,zz); // z = a + b x ; k=b ; x0=-a/b
  const k = b;
  if(Math.abs(k)<1e-9) return null;
  const x0hat = -a/b;
  return {L, k, x0: x0hat};
}

/* =========================
   PLOTS
========================= */
function getVarMeta(varKey){
  return VAR_META[varKey] || {name: varKey, unit:"", desc:"Indicador climático (sem descrição cadastrada)."};
}

function buildTimeAxis(rows){
  // x as Date for monthly; as year number for annual
  if(state.scale==="monthly"){
    return rows.map(r => new Date(r.year, (r.month||1)-1, 1));
  }
  return rows.map(r => r.year);
}

function calcMinMaxBands(rows, vkey){
  // for each time point, min=max=mean because aggregated dataset already monthly/annual (single value).
  // But we still compute global min/max for shade. For "faixa min-max" across selection, we plot constants.
  const vals = rows.map(r=>r[vkey]).filter(Number.isFinite);
  const lo = Math.min(...vals);
  const hi = Math.max(...vals);
  return {lo, hi};
}

function computeTrend(rows, vkey){
  const xs = [];
  const ys = [];
  for(const r of rows){
    const y = r[vkey];
    if(!Number.isFinite(y)) continue;
    if(state.scale==="monthly"){
      const t = r.year + ((r.month||1)-1)/12;
      xs.push(t);
    } else {
      xs.push(r.year);
    }
    ys.push(y);
  }
  if(xs.length<4) return {yhat:null, info:"Sem dados suficientes para tendência."};

  const mode = state.trend;
  let yhat = null, info="";

  if(mode==="none"){
    return {yhat:null, info:""};
  } else if(mode==="linear"){
    const {a,b} = linreg(xs,ys);
    yhat = xs.map(x=>a+b*x);
    const r2 = r2Score(ys,yhat);
    info = `Tendência linear: y = ${a.toFixed(3)} + ${b.toFixed(3)}·t  |  R² = ${Number.isFinite(r2)?r2.toFixed(3):"—"}`;
  } else if(mode==="poly2" || mode==="poly3"){
    const deg = (mode==="poly2")?2:3;
    const coef = polyFit(xs,ys,deg);
    yhat = polyEval(coef,xs);
    const r2 = r2Score(ys,yhat);
    info = `Tendência polinomial (grau ${deg}): R² = ${Number.isFinite(r2)?r2.toFixed(3):"—"}`;
  } else if(mode==="exp"){
    const m = expFit(xs,ys);
    if(!m){
      info = "Exponencial: precisa de valores positivos suficientes (y>0).";
    } else {
      yhat = expEval(m,xs);
      const r2 = r2Score(ys,yhat);
      info = `Tendência exponencial: y = ${m.A.toFixed(3)}·e^{${m.B.toFixed(3)}·t}  |  R² = ${Number.isFinite(r2)?r2.toFixed(3):"—"}`;
    }
  } else if(mode==="logistic"){
    const m = logisticFitSimple(xs,ys);
    if(!m){
      info = "Logística: não convergiu (série pode não ter saturação clara).";
    } else {
      yhat = logisticEval(m,xs);
      const r2 = r2Score(ys,yhat);
      info = `Tendência logística: L=${m.L.toFixed(3)}, k=${m.k.toFixed(3)}, x0=${m.x0.toFixed(3)}  |  R² = ${Number.isFinite(r2)?r2.toFixed(3):"—"}`;
    }
  }
  return {xs, ys, yhat, info};
}

function plotSeries(){
  const rows = getSelectionRows();
  const vkey = state.var;
  if(!vkey){
    Plotly.purge("plotSeries");
    return;
  }
  const meta = getVarMeta(vkey);
  const x = buildTimeAxis(rows);
  const y = rows.map(r=>r[vkey]);

  // cards
  const yFinite = y.filter(Number.isFinite);
  document.getElementById("kMean").textContent = fmt(mean(yFinite)) + (meta.unit?` ${meta.unit}`:"");
  document.getElementById("kMedian").textContent = fmt(median(yFinite)) + (meta.unit?` ${meta.unit}`:"");
  document.getElementById("kMin").textContent = fmt(Math.min(...yFinite)) + (meta.unit?` ${meta.unit}`:"");
  document.getElementById("kMax").textContent = fmt(Math.max(...yFinite)) + (meta.unit?` ${meta.unit}`:"");

  const {lo, hi} = calcMinMaxBands(rows, vkey);

  const base = {
    x, y,
    type:"scatter",
    mode:"lines+markers",
    name:`${meta.name} (média)`,
    line:{width:3},
    marker:{size:6},
    hovertemplate: state.scale==="monthly"
      ? "%{x|%b %Y}<br><b>%{y:.3f}</b> "+meta.unit+"<extra></extra>"
      : "%{x}<br><b>%{y:.3f}</b> "+meta.unit+"<extra></extra>"
  };

  const tMin = {
    x, y: x.map(()=>lo),
    type:"scatter",
    mode:"lines",
    name:"Mín (seleção)",
    line:{width:2, dash:"dot"},
    hoverinfo:"skip"
  };
  const tMax = {
    x, y: x.map(()=>hi),
    type:"scatter",
    mode:"lines",
    name:"Máx (seleção)",
    line:{width:2, dash:"dot"},
    hoverinfo:"skip"
  };
  const band = {
    x: x.concat([...x].reverse()),
    y: x.map(()=>hi).concat(x.map(()=>lo).reverse()),
    type:"scatter",
    fill:"toself",
    fillcolor:"rgba(20,255,122,.10)",
    line:{width:0},
    name:"Faixa (min–max)",
    hoverinfo:"skip"
  };

  // trend
  const trMode = document.getElementById("selTrend").value;
  state.trend = trMode;
  const trend = computeTrend(rows, vkey);
  document.getElementById("trendInfo").textContent = trend.info || "";

  let trendTrace = null;
  if(trend.yhat && trend.yhat.length){
    // map yhat to same x-axis order: we used xs derived; easiest to rebuild xhat from xs
    const xhat = trend.xs.map(t=>{
      if(state.scale==="monthly"){
        const yr = Math.floor(t);
        const frac = t-yr;
        const mo = Math.round(frac*12)+1;
        return new Date(yr, mo-1, 1);
      }
      return t;
    });
    trendTrace = {
      x: xhat,
      y: trend.yhat,
      type:"scatter",
      mode:"lines",
      name:"Tendência",
      line:{width:4},
      hoverinfo:"skip"
    };
  }

  const layout = {
    title: {text:`Série temporal — <b>${meta.name}</b> (${meta.unit||"—"})`, font:{size:16}},
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,0)",
    margin:{l:60,r:20,t:60,b:50},
    xaxis:{
      gridcolor:"rgba(255,255,255,.08)",
      tickfont:{color:"rgba(255,255,255,.85)"},
      zeroline:false
    },
    yaxis:{
      title: meta.unit ? meta.unit : "",
      gridcolor:"rgba(255,255,255,.08)",
      tickfont:{color:"rgba(255,255,255,.85)"},
      zeroline:false
    },
    legend:{orientation:"h", y:-0.18},
  };

  const data = trendTrace ? [band, tMin, tMax, base, trendTrace] : [band, tMin, tMax, base];

  Plotly.newPlot("plotSeries", data, layout, {responsive:true, displaylogo:false});
}

function plotBox(){
  const rows = getSelectionRows();
  const vkey = state.var;
  if(!vkey){
    Plotly.purge("plotBox");
    return;
  }
  if(state.scale!=="monthly"){
    Plotly.newPlot("plotBox", [], {
      title:{text:"Boxplot disponível apenas na escala <b>Mensal</b>.", font:{size:16}},
      paper_bgcolor:"rgba(0,0,0,0)", plot_bgcolor:"rgba(0,0,0,0)"
    }, {responsive:true, displaylogo:false});
    return;
  }

  const meta = getVarMeta(vkey);

  // GROUP values by month
  const byM = new Map();
  for(const m of months) byM.set(m.n, []);
  for(const r of rows){
    const m = r.month;
    const v = r[vkey];
    if(Number.isFinite(m) && Number.isFinite(v) && byM.has(m)){
      byM.get(m).push(v);
    }
  }

  // REAL BOXPLOT traces
  const traces = months.map(m=>{
    return {
      type:"box",
      name: m.lab,
      y: byM.get(m.n),
      boxpoints:false,           // sem pontos (mais limpo)
      whiskerwidth:0.8,
      marker:{size:3},
      line:{width:2},
    };
  });

  const layout = {
    title:{text:`Boxplot mensal — <b>${meta.name}</b> (${meta.unit||"—"})`, font:{size:16}},
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,0)",
    margin:{l:60,r:20,t:60,b:50},
    xaxis:{
      title:"Mês",
      gridcolor:"rgba(255,255,255,.08)",
      tickfont:{color:"rgba(255,255,255,.85)"},
      zeroline:false
    },
    yaxis:{
      title: meta.unit ? meta.unit : "",
      gridcolor:"rgba(255,255,255,.08)",
      tickfont:{color:"rgba(255,255,255,.85)"},
      zeroline:false
    },
    showlegend:false
  };

  Plotly.newPlot("plotBox", traces, layout, {responsive:true, displaylogo:false});
}

function plotScatter(){
  const rows = getSelectionRows();
  const xk = state.x;
  const yk = state.y;
  if(!xk || !yk){
    Plotly.purge("plotScatter");
    return;
  }
  const mx = getVarMeta(xk);
  const my = getVarMeta(yk);

  const lag = Number(document.getElementById("selLag").value || 0);
  state.lag = lag;

  // build aligned arrays by time order
  const rr = rows.slice().sort((a,b)=>{
    if(a.year!==b.year) return a.year-b.year;
    return (a.month||0)-(b.month||0);
  });

  const xs=[], ys=[];
  for(let i=0;i<rr.length;i++){
    const j = i+lag;
    if(j>=rr.length) break;
    const xv = rr[i][xk];
    const yv = rr[j][yk];
    if(Number.isFinite(xv) && Number.isFinite(yv)){
      xs.push(xv);
      ys.push(yv);
    }
  }

  if(xs.length<4){
    Plotly.newPlot("plotScatter", [], {
      title:{text:"Poucos dados para dispersão (ajuste anos/meses).", font:{size:16}},
      paper_bgcolor:"rgba(0,0,0,0)", plot_bgcolor:"rgba(0,0,0,0)"
    }, {responsive:true, displaylogo:false});
    return;
  }

  const lr = linreg(xs,ys);
  const yhat = xs.map(x=>lr.a + lr.b*x);
  const r2 = r2Score(ys, yhat);

  // line
  const xmin = Math.min(...xs), xmax = Math.max(...xs);
  const lx = [xmin, xmax];
  const ly = lx.map(x=>lr.a + lr.b*x);

  const scatter = {
    x: xs, y: ys,
    type:"scatter",
    mode:"markers",
    name:"Pontos",
    marker:{size:8, opacity:.85},
    hovertemplate:`<b>X</b>: %{x:.3f} ${mx.unit||""}<br><b>Y</b>: %{y:.3f} ${my.unit||""}<extra></extra>`
  };
  const line = {
    x: lx, y: ly,
    type:"scatter",
    mode:"lines",
    name:`Regressão (R²=${Number.isFinite(r2)?r2.toFixed(3):"—"})`,
    line:{width:4},
    hoverinfo:"skip"
  };

  const layout = {
    title:{text:`Dispersão — <b>${mx.name}</b> × <b>${my.name}</b> (lag=${lag})`, font:{size:16}},
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"rgba(0,0,0,0)",
    margin:{l:60,r:20,t:60,b:50},
    xaxis:{
      title: mx.unit ? `${mx.name} (${mx.unit})` : mx.name,
      gridcolor:"rgba(255,255,255,.08)",
      tickfont:{color:"rgba(255,255,255,.85)"},
      zeroline:false
    },
    yaxis:{
      title: my.unit ? `${my.name} (${my.unit})` : my.name,
      gridcolor:"rgba(255,255,255,.08)",
      tickfont:{color:"rgba(255,255,255,.85)"},
      zeroline:false
    },
    legend:{orientation:"h", y:-0.18},
    annotations: [{
      xref:"paper", yref:"paper", x:0.02, y:0.98, showarrow:false,
      text:`<span style="font-family:var(--mono)">y = ${lr.a.toFixed(3)} + ${lr.b.toFixed(3)}·x<br>R² = ${Number.isFinite(r2)?r2.toFixed(3):"—"}</span>`,
      bgcolor:"rgba(0,0,0,.35)",
      bordercolor:"rgba(255,255,255,.12)",
      borderwidth:1,
      font:{color:"rgba(255,255,255,.9)", size:12},
      align:"left"
    }]
  };

  Plotly.newPlot("plotScatter", [scatter, line], layout, {responsive:true, displaylogo:false});
}

function renderTable(){
  const rows = getSelectionRows();
  const vkey = state.var;
  if(!vkey){
    document.getElementById("tbl").innerHTML = "";
    return;
  }
  const meta = getVarMeta(vkey);

  const head = `
    <thead>
      <tr>
        <th>Escala</th>
        <th>Período</th>
        <th>${meta.name} <span class="mono">(${meta.unit||"—"})</span></th>
      </tr>
    </thead>
  `;
  const bodyRows = rows
    .filter(r=>Number.isFinite(r[vkey]))
    .slice(0, 2500)
    .map(r=>`<tr>
      <td class="mono">${r.scale}</td>
      <td class="mono">${r.period}</td>
      <td>${fmt(r[vkey], 3)}</td>
    </tr>`).join("");

  document.getElementById("tbl").innerHTML = head + `<tbody>${bodyRows}</tbody>`;
}

/* =========================
   UI BUILD
========================= */
function buildVarSelects(vars){
  const selVar = document.getElementById("selVar");
  const selX = document.getElementById("selX");
  const selY = document.getElementById("selY");

  const opts = vars.map(v=>{
    const m = getVarMeta(v);
    const label = `${m.name} (${v})${m.unit?` — ${m.unit}`:""}`;
    return `<option value="${v}">${label}</option>`;
  }).join("");

  selVar.innerHTML = opts;
  selX.innerHTML = `<option value="">Variável X</option>` + opts;
  selY.innerHTML = `<option value="">Variável Y</option>` + opts;

  // default
  state.var = vars.includes("temperature_2m") ? "temperature_2m" : vars[0];
  selVar.value = state.var;

  // default scatter
  state.x = vars.includes("dewpoint_2m") ? "dewpoint_2m" : vars[0];
  state.y = vars.includes("relative_humidity_2m") ? "relative_humidity_2m" : (vars[1]||vars[0]);
  selX.value = state.x;
  selY.value = state.y;
}

function updateVarDescription(){
  const v = document.getElementById("selVar").value;
  state.var = v;
  const m = getVarMeta(v);

  // show description in trendInfo (baixo dos cards) + title already.
  const d = `Indicador: ${m.name} • unidade: ${m.unit||"—"} • ${m.desc}`;
  const el = document.getElementById("trendInfo");
  // keep trend line below; we’ll append trend info later in plotSeries()
  // We'll store desc in dataset:
  el.dataset.desc = d;
}

/* =========================
   EVENTS
========================= */
function bindEvents(){
  // tabs
  document.querySelectorAll(".tab").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      document.querySelectorAll(".tab").forEach(b=>b.classList.remove("active"));
      document.querySelectorAll(".view").forEach(v=>v.classList.remove("active"));
      btn.classList.add("active");
      document.getElementById(btn.dataset.view).classList.add("active");
      recalc();
    });
  });

  const recalcSoon = ()=>{ window.requestAnimationFrame(recalc); };

  document.getElementById("selScale").addEventListener("change", (e)=>{
    state.scale = e.target.value;
    recalcSoon();
  });

  document.getElementById("selVar").addEventListener("change", ()=>{
    updateVarDescription();
    recalcSoon();
  });

  document.getElementById("yearStart").addEventListener("input", recalcSoon);
  document.getElementById("yearEnd").addEventListener("input", recalcSoon);
  document.getElementById("selMonthA").addEventListener("change", recalcSoon);
  document.getElementById("selMonthB").addEventListener("change", recalcSoon);
  document.getElementById("selTrend").addEventListener("change", recalcSoon);
  document.getElementById("selLag").addEventListener("change", recalcSoon);

  document.getElementById("selX").addEventListener("change", (e)=>{ state.x = e.target.value || null; recalcSoon(); });
  document.getElementById("selY").addEventListener("change", (e)=>{ state.y = e.target.value || null; recalcSoon(); });

  document.getElementById("btnReset").addEventListener("click", ()=>{
    // reset controls
    document.getElementById("selScale").value = "monthly";
    document.getElementById("selMonthA").value = "all";
    document.getElementById("selMonthB").value = "all";
    document.getElementById("selTrend").value = "none";
    document.getElementById("selLag").value = "0";
    document.getElementById("yearStart").value = "";
    document.getElementById("yearEnd").value = "";

    state.scale = "monthly";
    // keep var defaults
    recalc();
  });

  document.getElementById("btnExportCsv").addEventListener("click", ()=>{
    const rows = getSelectionRows();
    const vkey = state.var;
    if(!vkey) return;

    const out = rows.map(r=>{
      return {
        scale: r.scale,
        period: r.period,
        year: r.year,
        month: r.month ?? "",
        [vkey]: r[vkey]
      };
    });

    const csv = Papa.unparse(out);
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `caceres_${state.scale}_${vkey}_selecionado.csv`;
    a.click();
    URL.revokeObjectURL(a.href);
  });

  document.getElementById("btnSavePng").addEventListener("click", async ()=>{
    const activeView = document.querySelector(".view.active").id;
    const map = {vSeries:"plotSeries", vBox:"plotBox", vScatter:"plotScatter"};
    const divId = map[activeView] || "plotSeries";
    try{
      const dataUrl = await Plotly.toImage(divId, {format:"png", width:1400, height:850, scale:2});
      const a = document.createElement("a");
      a.href = dataUrl;
      a.download = `PLAC_Caceres_${divId}.png`;
      a.click();
    }catch(err){
      alert("Não consegui salvar PNG. Tente novamente.");
      console.error(err);
    }
  });
}

/* =========================
   RECALC
========================= */
function recalc(){
  setErr("");

  // enforce: month controls visible only in monthly (we keep them but just ignore in annual)
  const sc = document.getElementById("selScale").value;
  state.scale = sc;

  // show description + trend info
  updateVarDescription();

  // combine desc + trend line in same area
  const desc = document.getElementById("trendInfo").dataset.desc || "";
  document.getElementById("trendInfo").textContent = desc;

  // plots
  plotSeries();
  plotBox();
  plotScatter();
  renderTable();

  // append trend info under description (after plotSeries computed)
  const trend = document.getElementById("trendInfo").textContent;
  // plotSeries will overwrite trendInfo with trend line; so we keep desc there:
  // We'll reapply desc + trend:
  const vkey = state.var;
  if(vkey){
    const m = getVarMeta(vkey);
    const desc2 = `Indicador: ${m.name} • unidade: ${m.unit||"—"} • ${m.desc}`;
    // trendInfo already set by plotSeries; we merge:
    const t = document.getElementById("trendInfo").textContent;
    // if plotSeries put trend equation, keep it; else only desc
    if(t && t.startsWith("Tendência")){
      document.getElementById("trendInfo").textContent = desc2 + "  |  " + t;
    } else {
      document.getElementById("trendInfo").textContent = desc2 + (t?("  |  "+t):"");
    }
  }
}

/* =========================
   INIT
========================= */
async function init(){
  try{
    setErr("");
    setBar(2);

    const {rows, vars} = await loadGzCsv(DATA_URL);
    state.rows = rows;
    state.vars = vars;

    if(!vars.length){
      throw new Error(
        "Não encontrei colunas numéricas no CSV.\n" +
        "Possíveis causas: separador errado (; vs ,), cabeçalho inesperado, ou arquivo vazio."
      );
    }

    buildVarSelects(vars);

    // set default year range based on data
    const years = rows.map(r=>r.year).filter(Number.isFinite);
    const yMin = Math.min(...years), yMax = Math.max(...years);
    document.getElementById("yearStart").placeholder = `ex: ${yMin}`;
    document.getElementById("yearEnd").placeholder = `ex: ${yMax}`;

    bindEvents();
    setBar(100);
    setTimeout(()=>setBar(0), 700);

    recalc();
  }catch(err){
    console.error(err);
    setErr("Erro ao iniciar o painel:\n" + err.message + "\n\nConfira se o arquivo existe em:\n" + DATA_URL);
    setBar(0);
  }
}

init();
</script>
</body>
</html>
