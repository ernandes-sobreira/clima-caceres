<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PLAC Cáceres — Painel Climático Interativo</title>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root{
      --bg:#f7fafc;
      --card:#ffffff;
      --text:#0f172a;
      --muted:#475569;
      --line:#e2e8f0;

      /* palette (vermelho, verde, azul) */
      --red:#dc2626;
      --red2:#ef4444;
      --green:#16a34a;
      --blue:#2563eb;

      --shadow: 0 14px 40px rgba(2,6,23,.10);
      --r:18px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 700px at 20% -10%, rgba(37,99,235,.12), transparent 50%),
                  radial-gradient(1200px 700px at 90% 0%, rgba(220,38,38,.14), transparent 55%),
                  radial-gradient(900px 600px at 40% 110%, rgba(22,163,74,.10), transparent 55%),
                  var(--bg);
      color:var(--text);
    }

    header{
      position:sticky; top:0; z-index:20;
      background: rgba(255,255,255,.82);
      backdrop-filter: blur(10px);
      border-bottom:1px solid var(--line);
    }
    .top{
      max-width:1200px; margin:0 auto;
      padding:14px 16px;
      display:flex; gap:12px; align-items:center; justify-content:space-between;
    }
    .brand{
      display:flex; gap:12px; align-items:center;
      min-width:260px;
    }
    .logo{
      width:42px; height:42px; border-radius:14px;
      background: conic-gradient(from 220deg, var(--blue), var(--green), var(--red), var(--blue));
      box-shadow: 0 10px 22px rgba(2,6,23,.14);
    }
    .title h1{margin:0; font-size:16px; line-height:1.1}
    .title p{margin:2px 0 0; font-size:12px; color:var(--muted)}
    .actions{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end}

    .btn{
      appearance:none; border:1px solid var(--line);
      background: linear-gradient(180deg, #fff, #fafafa);
      color:var(--text);
      padding:10px 12px;
      border-radius: 14px;
      cursor:pointer;
      font-weight:700;
      font-size:12px;
      box-shadow: 0 10px 24px rgba(2,6,23,.06);
      transition: transform .08s ease, box-shadow .08s ease, border-color .08s ease;
      display:inline-flex; gap:8px; align-items:center;
    }
    .btn:hover{transform: translateY(-1px); box-shadow: 0 14px 34px rgba(2,6,23,.10)}
    .btn:active{transform: translateY(0px)}
    .btn.red{border-color: rgba(220,38,38,.25)}
    .btn.blue{border-color: rgba(37,99,235,.25)}
    .btn.green{border-color: rgba(22,163,74,.25)}

    main{max-width:1200px; margin:0 auto; padding:16px}
    .grid{
      display:grid;
      grid-template-columns: 360px 1fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr}
      .brand{min-width: unset}
    }

    .card{
      background: rgba(255,255,255,.92);
      border: 1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card h2{
      margin:0;
      padding:12px 14px;
      font-size:13px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between;
      background: linear-gradient(180deg, rgba(37,99,235,.08), transparent);
    }
    .card .body{padding:12px 14px}
    label{display:block; font-size:12px; color:var(--muted); margin:10px 0 6px}
    select, input[type="date"], input[type="number"]{
      width:100%;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--line);
      background:#fff;
      font-size:13px;
      outline:none;
    }

    .row2{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      font-size:12px;
      cursor:pointer;
      user-select:none;
      background:#fff;
      font-weight:700;
    }
    .pill input{margin:0}
    .kpis{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; margin-top:10px}
    .kpi{
      background:#fff;
      border:1px solid var(--line);
      border-radius:16px;
      padding:10px;
    }
    .kpi .k{font-size:11px; color:var(--muted)}
    .kpi .v{font-size:14px; font-weight:800; margin-top:4px}
    .muted{color:var(--muted); font-size:12px; line-height:1.4}
    .tabs{display:flex; gap:8px; flex-wrap:wrap; padding:10px 12px; border-bottom:1px solid var(--line)}
    .tab{
      border:1px solid var(--line);
      background:#fff;
      padding:8px 10px;
      border-radius:999px;
      cursor:pointer;
      font-size:12px;
      font-weight:800;
    }
    .tab.active{border-color: rgba(37,99,235,.35); box-shadow: 0 10px 26px rgba(37,99,235,.10)}
    .plotWrap{padding:12px}
    .plot{width:100%; height:520px;}
    .small{font-size:11px}
    .note{
      padding:10px 12px;
      border:1px dashed rgba(220,38,38,.35);
      border-radius:16px;
      background: rgba(220,38,38,.05);
      color:#7f1d1d;
      font-size:12px;
      line-height:1.45;
      margin-top:10px;
    }
    .good{
      border-color: rgba(22,163,74,.35);
      background: rgba(22,163,74,.06);
      color:#14532d;
    }
    .bluebox{
      border-color: rgba(37,99,235,.35);
      background: rgba(37,99,235,.06);
      color:#1e3a8a;
    }
    .hr{height:1px; background:var(--line); margin:12px 0}
    .spinner{
      display:none;
      align-items:center;
      gap:10px;
      font-size:12px;
      color:var(--muted);
      margin-top:10px;
    }
    .dot{
      width:10px; height:10px; border-radius:99px;
      background: var(--blue);
      animation: pulse 1.2s infinite ease-in-out;
    }
    @keyframes pulse{
      0%,100%{transform:scale(1); opacity:.6}
      50%{transform:scale(1.6); opacity:1}
    }
  </style>
</head>
<body>
<header>
  <div class="top">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div class="title">
        <h1>PLAC Cáceres — Painel Climático Interativo</h1>
        <p>Dados diários (ERA5-Land via GEE) • estatística, tendências e comparações</p>
      </div>
    </div>
    <div class="actions">
      <button class="btn blue" id="btnPNG">Salvar gráfico (PNG)</button>
      <button class="btn green" id="btnCSV">Exportar seleção (CSV)</button>
      <button class="btn red" id="btnReset">Reset</button>
    </div>
  </div>
</header>

<main>
  <div class="grid">
    <section class="card">
      <h2>Controles</h2>
      <div class="body">
        <label>Município (comparação até 5)</label>
        <select id="selCities" multiple size="5"></select>
        <div style="display:flex; gap:10px; margin-top:10px">
          <button class="btn blue" id="btnAddCity" style="flex:1">Adicionar município (CSV)</button>
          <button class="btn red" id="btnRemoveCity" style="flex:1">Remover (exceto Cáceres)</button>
        </div>
        <input id="fileCity" type="file" accept=".csv,.csv.gz" style="display:none" />

        <div class="hr"></div>

        <label>Variável principal</label>
        <select id="selVar"></select>

        <div class="row2">
          <div>
            <label>Agregação temporal</label>
            <select id="selAgg">
              <option value="daily">Diário</option>
              <option value="monthly">Mensal</option>
              <option value="yearly">Anual</option>
            </select>
          </div>
          <div>
            <label>Resumo no período</label>
            <select id="selReducer">
              <option value="auto">Auto (recomendado)</option>
              <option value="mean">Média</option>
              <option value="sum">Soma</option>
              <option value="min">Mín</option>
              <option value="max">Máx</option>
            </select>
          </div>
        </div>

        <div class="row2">
          <div>
            <label>Início</label>
            <input id="dateStart" type="date">
          </div>
          <div>
            <label>Fim</label>
            <input id="dateEnd" type="date">
          </div>
        </div>

        <label class="pill"><input type="checkbox" id="chkHideSnow" checked> Ocultar neve/gelo</label>

        <div class="kpis" id="kpis"></div>

        <div class="note bluebox" id="varInfo">
          Carregando descrição da variável…
        </div>

        <div class="note good" id="trendBox">
          Tendência: calculada automaticamente (Mann-Kendall + Sen).
        </div>

        <div class="spinner" id="spin">
          <span class="dot"></span><span id="spinTxt">Carregando dados…</span>
        </div>

        <div class="hr"></div>

        <h3 style="margin:0; font-size:12px">Comparação entre variáveis</h3>
        <label>Variável X</label>
        <select id="selX"></select>
        <label>Variável Y</label>
        <select id="selY"></select>
        <label>Defasagem para Y (lags)</label>
        <select id="selLag">
          <option value="0">0</option>
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="6">6</option>
          <option value="12">12</option>
        </select>
        <p class="muted small">Em mensal/anual, “lag=1” significa 1 mês/1 ano. Em diário, 1 dia.</p>
      </div>
    </section>

    <section class="card">
      <div class="tabs">
        <button class="tab active" data-tab="ts">Série temporal</button>
        <button class="tab" data-tab="box">Boxplot (meses)</button>
        <button class="tab" data-tab="scatter">Dispersão + regressão</button>
        <button class="tab" data-tab="table">Tabela</button>
      </div>
      <div class="plotWrap">
        <div id="plot" class="plot"></div>
        <div id="tableWrap" style="display:none"></div>
      </div>
    </section>
  </div>
</main>

<script>
/* =========================
   Config
========================= */
const DEFAULT_CITY = "Cáceres";
const DATA_URL = "data/caceres_era5land_daily.csv.gz"; // <-- CORRETO (gz)

const SNOW_KEYWORDS = ["snow","ice","glacier","sea_ice","snowfall","snowmelt","snow_depth","ice_temperature"];

const state = {
  datasets: {},  // city -> rows
  vars: [],
  activeTab: "ts",
};

/* =========================
   Utils
========================= */
function isSnowVar(name){
  const n = name.toLowerCase();
  return SNOW_KEYWORDS.some(k=>n.includes(k));
}

function niceName(col){
  // human-friendly label (compact)
  return col
    .replaceAll("_"," ")
    .replaceAll("2m","2 m")
    .replace(/\bmax\b/i,"(máx)")
    .replace(/\bmin\b/i,"(mín)")
    .replace(/\bsum\b/i,"(soma)");
}

function autoReducer(col){
  const c = col.toLowerCase();
  if(c.endsWith("_sum")) return "sum";
  if(c.endsWith("_min")) return "min";
  if(c.endsWith("_max")) return "max";
  return "mean";
}

function toDate(d){
  // expects YYYY-MM-DD
  return new Date(d + "T00:00:00");
}

function fmt(v){
  if(v==null || Number.isNaN(v)) return "—";
  if(Math.abs(v) >= 1e6) return v.toExponential(2);
  if(Math.abs(v) >= 1000) return v.toFixed(0);
  if(Math.abs(v) >= 10) return v.toFixed(2);
  return v.toFixed(3);
}

function downloadBlob(filename, mime, data){
  const blob = new Blob([data], {type:mime});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url; a.download=filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1200);
}

async function loadGzText(url){
  const resp = await fetch(url);
  if(!resp.ok) throw new Error("Não consegui carregar: " + url);
  const buffer = await resp.arrayBuffer();
  const decompressed = window.pako.ungzip(new Uint8Array(buffer));
  return new TextDecoder("utf-8").decode(decompressed);
}

/* =========================
   Stats (MK + Sen)
========================= */
function mannKendall(x){
  // x: array of numbers (no NaN)
  const n = x.length;
  if(n < 8) return null;

  let S = 0;
  for(let i=0;i<n-1;i++){
    for(let j=i+1;j<n;j++){
      const diff = x[j]-x[i];
      if(diff>0) S += 1;
      else if(diff<0) S -= 1;
    }
  }

  // tie correction
  const sorted = [...x].sort((a,b)=>a-b);
  let ties = [];
  let run = 1;
  for(let i=1;i<n;i++){
    if(sorted[i]===sorted[i-1]) run++;
    else { if(run>1) ties.push(run); run=1; }
  }
  if(run>1) ties.push(run);

  let varS = (n*(n-1)*(2*n+5))/18;
  if(ties.length){
    let tieSum = 0;
    for(const t of ties){
      tieSum += t*(t-1)*(2*t+5);
    }
    varS -= tieSum/18;
  }

  let Z = 0;
  if(S>0) Z = (S-1)/Math.sqrt(varS);
  else if(S<0) Z = (S+1)/Math.sqrt(varS);

  // two-sided p (normal approx)
  const p = 2*(1 - normalCdf(Math.abs(Z)));

  // Sen slope
  const slopes = [];
  for(let i=0;i<n-1;i++){
    for(let j=i+1;j<n;j++){
      slopes.push((x[j]-x[i])/(j-i));
    }
  }
  slopes.sort((a,b)=>a-b);
  const sen = slopes.length%2 ? slopes[(slopes.length-1)/2] : 0.5*(slopes[slopes.length/2-1]+slopes[slopes.length/2]);

  // Kendall tau
  const tau = S / (0.5*n*(n-1));

  return {S, Z, p, tau, sen};
}

// error function approximation for normal CDF
function erf(x){
  const sign = x>=0 ? 1 : -1;
  x = Math.abs(x);
  const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
  const p=0.3275911;
  const t = 1/(1+p*x);
  const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
  return sign*y;
}
function normalCdf(z){ return 0.5*(1+erf(z/Math.SQRT2)); }

function pearson(x,y){
  const n=x.length;
  const mx = x.reduce((a,b)=>a+b,0)/n;
  const my = y.reduce((a,b)=>a+b,0)/n;
  let num=0, dx=0, dy=0;
  for(let i=0;i<n;i++){
    const vx=x[i]-mx, vy=y[i]-my;
    num += vx*vy; dx += vx*vx; dy += vy*vy;
  }
  const r = num/Math.sqrt(dx*dy);
  return r;
}
function rank(arr){
  // average ranks for ties
  const indexed = arr.map((v,i)=>({v,i})).sort((a,b)=>a.v-b.v);
  const ranks = new Array(arr.length);
  let i=0;
  while(i<indexed.length){
    let j=i;
    while(j<indexed.length && indexed[j].v===indexed[i].v) j++;
    const avg = (i+1 + j)/2;
    for(let k=i;k<j;k++) ranks[indexed[k].i]=avg;
    i=j;
  }
  return ranks;
}
function spearman(x,y){
  const rx=rank(x), ry=rank(y);
  return pearson(rx,ry);
}
function olsSlopeP(x,y){
  // slope, intercept, p-value for slope (t-test)
  const n=x.length;
  const mx=x.reduce((a,b)=>a+b,0)/n;
  const my=y.reduce((a,b)=>a+b,0)/n;
  let Sxx=0,Sxy=0;
  for(let i=0;i<n;i++){ Sxx += (x[i]-mx)**2; Sxy += (x[i]-mx)*(y[i]-my); }
  const slope = Sxy/Sxx;
  const intercept = my - slope*mx;

  // residuals
  let rss=0;
  for(let i=0;i<n;i++){
    const yhat = intercept + slope*x[i];
    rss += (y[i]-yhat)**2;
  }
  const se2 = rss/(n-2);
  const seSlope = Math.sqrt(se2/Sxx);
  const t = slope/seSlope;

  const p = 2*(1 - studentTCdf(Math.abs(t), n-2)); // approximate
  return {slope, intercept, p};
}

// Student t CDF approximation using incomplete beta (numerical)
function studentTCdf(t, df){
  // for df>1
  const x = df/(df + t*t);
  const a = df/2;
  const b = 0.5;
  const ib = incompleteBeta(x, a, b);
  const cdf = 1 - 0.5*ib;
  return cdf;
}
function incompleteBeta(x,a,b){
  // continued fraction approximation (Lentz)
  const MAXIT=200, EPS=3e-9, FPMIN=1e-30;
  function betacf(x,a,b){
    let qab=a+b, qap=a+1, qam=a-1;
    let c=1, d=1 - qab*x/qap;
    if(Math.abs(d)<FPMIN) d=FPMIN;
    d=1/d;
    let h=d;
    for(let m=1;m<=MAXIT;m++){
      let m2=2*m;
      let aa = m*(b-m)*x/((qam+m2)*(a+m2));
      d = 1 + aa*d; if(Math.abs(d)<FPMIN) d=FPMIN; d=1/d;
      c = 1 + aa/c; if(Math.abs(c)<FPMIN) c=FPMIN;
      h *= d*c;
      aa = -(a+m)*(qab+m)*x/((a+m2)*(qap+m2));
      d = 1 + aa*d; if(Math.abs(d)<FPMIN) d=FPMIN; d=1/d;
      c = 1 + aa/c; if(Math.abs(c)<FPMIN) c=FPMIN;
      const del = d*c;
      h *= del;
      if(Math.abs(del-1.0) < EPS) break;
    }
    return h;
  }
  function logGamma(z){
    // Lanczos
    const p=[676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-0.13857109526572012,9.984369578019571e-6,1.5056327351493116e-7];
    if(z<0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI*z)) - logGamma(1-z);
    z -= 1;
    let x=0.99999999999980993;
    for(let i=0;i<p.length;i++) x += p[i]/(z+i+1);
    const t=z+p.length-0.5;
    return 0.5*Math.log(2*Math.PI) + (z+0.5)*Math.log(t) - t + Math.log(x);
  }
  function beta(a,b){ return Math.exp(logGamma(a)+logGamma(b)-logGamma(a+b)); }

  if(x<=0) return 0;
  if(x>=1) return 1;
  const bt = Math.exp(Math.log(x)*a + Math.log(1-x)*b - Math.log(beta(a,b)));
  if(x < (a+1)/(a+b+2)) return bt*betacf(x,a,b)/a;
  return 1 - bt*betacf(1-x,b,a)/b;
}

/* =========================
   Variable dictionary (lightweight)
========================= */
function describeVar(col){
  const c = col.toLowerCase();
  let unit = "";
  let meaning = "";
  let note = "";

  const looksK = (v)=> (v!=null && isFinite(v) && v>120 && v<400);
  // unit heuristics
  if(c.includes("temperature")) unit = "K (convertido para °C quando aplicável)";
  if(c.includes("dewpoint")) unit = "K (convertido para °C quando aplicável)";
  if(c.includes("precip") || c.includes("rain")) unit = "m (convertido para mm quando aplicável)";
  if(c.includes("evap")) unit = "m (convertido para mm quando aplicável)";
  if(c.includes("runoff")) unit = "m (convertido para mm quando aplicável)";
  if(c.includes("wind")) unit = "m/s";
  if(c.includes("pressure")) unit = "Pa";
  if(c.includes("humidity")) unit = "% (quando derivada)";
  if(c.includes("radiation") || c.includes("solar")) unit = "J/m²";
  if(c.includes("albedo")) unit = "fração (0–1)";

  // meaning heuristics
  if(c.includes("temperature_2m")) meaning = "Temperatura do ar (2 m): indicador direto de aquecimento, conforto térmico e estresse por calor.";
  else if(c.includes("dewpoint")) meaning = "Ponto de orvalho: indica a umidade do ar e a sensação térmica (calor úmido é mais perigoso).";
  else if(c.includes("precip")) meaning = "Precipitação: controla seca/cheia, recarga hídrica e risco de incêndios (déficit hídrico).";
  else if(c.includes("evap")) meaning = "Evaporação: perda de água para a atmosfera; cresce com calor/vento e piora o déficit hídrico.";
  else if(c.includes("runoff")) meaning = "Escoamento: água que escoa superficialmente; relaciona-se a enchentes, erosão e disponibilidade hídrica.";
  else if(c.includes("wind")) meaning = "Vento: influencia evaporação, dispersão de fumaça/poluentes e propagação do fogo.";
  else if(c.includes("radiation") || c.includes("solar")) meaning = "Radiação: energia disponível; impulsiona aquecimento e evapotranspiração.";
  else if(c.includes("pressure")) meaning = "Pressão: padrão sinótico; ajuda a explicar regimes de chuva e eventos extremos.";
  else meaning = "Variável climática/energética relevante para caracterizar o regime local e subsidiar políticas do PLAC.";

  if(isSnowVar(col)) note = "Variável relacionada a neve/gelo (geralmente irrelevante para Cáceres).";
  return {unit, meaning, note};
}

function convertIfNeeded(col, arr){
  // returns {arr, unitHint}
  const c = col.toLowerCase();
  let unitHint = "";
  const out = arr.slice();

  // Kelvin -> Celsius if plausible
  if(c.includes("temperature") || c.includes("dewpoint")){
    const sample = out.find(v=>isFinite(v));
    if(sample != null && sample > 120){
      for(let i=0;i<out.length;i++) if(isFinite(out[i])) out[i] = out[i]-273.15;
      unitHint = "°C";
    }
  }

  // meters -> mm for precip/evap/runoff sums
  if(c.includes("precip") || c.includes("evap") || c.includes("runoff")){
    const sample = out.find(v=>isFinite(v));
    if(sample != null && Math.abs(sample) < 5){ // typical meters
      for(let i=0;i<out.length;i++) if(isFinite(out[i])) out[i] = out[i]*1000;
      unitHint = "mm";
    }
  }

  // albedo already fraction
  if(c.includes("albedo")) unitHint = "0–1";

  return {arr: out, unitHint};
}

/* =========================
   Data prep
========================= */
function getSelectedCities(){
  const sel = document.getElementById("selCities");
  const out = [];
  for(const opt of sel.options) if(opt.selected) out.push(opt.value);
  return out.length ? out : [DEFAULT_CITY];
}

function parseRows(rows){
  // normalize & add dateParts
  return rows.map(r=>{
    const d = (r.date || r.Date || r.DATA || r.data || "").slice(0,10);
    const dt = d ? toDate(d) : null;
    return {...r, __date: d, __dt: dt, __year: dt?dt.getFullYear():null, __month: dt?(dt.getMonth()+1):null};
  }).filter(r=>r.__dt);
}

function groupAgg(rows, col, agg, reducer){
  // returns {t:[], y:[]}
  const red = reducer==="auto" ? autoReducer(col) : reducer;
  const map = new Map();
  for(const r of rows){
    const v = Number(r[col]);
    if(!isFinite(v)) continue;
    let key;
    if(agg==="daily") key = r.__date;
    else if(agg==="monthly") key = `${r.__year}-${String(r.__month).padStart(2,"0")}-01`;
    else key = `${r.__year}-01-01`;
    if(!map.has(key)) map.set(key, []);
    map.get(key).push(v);
  }
  const keys = [...map.keys()].sort();
  const t=[], y=[];
  for(const k of keys){
    const arr = map.get(k);
    let val;
    if(red==="mean") val = arr.reduce((a,b)=>a+b,0)/arr.length;
    else if(red==="sum") val = arr.reduce((a,b)=>a+b,0);
    else if(red==="min") val = Math.min(...arr);
    else if(red==="max") val = Math.max(...arr);
    else val = arr.reduce((a,b)=>a+b,0)/arr.length;
    t.push(k); y.push(val);
  }
  const conv = convertIfNeeded(col, y);
  return {t, y: conv.arr, unitHint: conv.unitHint, reducerUsed: red};
}

function filterByDate(rows, start, end){
  const s = start ? toDate(start) : null;
  const e = end ? toDate(end) : null;
  return rows.filter(r=>{
    if(!r.__dt) return false;
    if(s && r.__dt < s) return false;
    if(e && r.__dt > e) return false;
    return true;
  });
}

/* =========================
   UI build
========================= */
function buildCitySelect(){
  const sel = document.getElementById("selCities");
  const current = new Set(getSelectedCities());
  sel.innerHTML = "";
  const cities = Object.keys(state.datasets);
  for(const c of cities){
    const opt = document.createElement("option");
    opt.value = c; opt.textContent = c;
    if(current.has(c) || (current.size===0 && c===DEFAULT_CITY)) opt.selected = true;
    sel.appendChild(opt);
  }
  if(!cities.includes(DEFAULT_CITY)){
    const opt = document.createElement("option");
    opt.value = DEFAULT_CITY; opt.textContent = DEFAULT_CITY; opt.selected = true;
    sel.prepend(opt);
  }
}

function buildVarSelects(){
  const hideSnow = document.getElementById("chkHideSnow").checked;
  const vars = state.vars.filter(v=>{
    if(v==="date" || v==="system:index" || v==="doy") return false;
    if(hideSnow && isSnowVar(v)) return false;
    return true;
  });

  const selVar = document.getElementById("selVar");
  const selX = document.getElementById("selX");
  const selY = document.getElementById("selY");
  const keep = selVar.value || vars[0];

  for(const sel of [selVar, selX, selY]) sel.innerHTML = "";
  for(const v of vars){
    const opt1 = new Option(niceName(v), v);
    const opt2 = new Option(niceName(v), v);
    const opt3 = new Option(niceName(v), v);
    selVar.add(opt1); selX.add(opt2); selY.add(opt3);
  }
  if(vars.includes(keep)) selVar.value = keep;

  // default X/Y if empty
  if(!selX.value) selX.value = vars[0];
  if(!selY.value) selY.value = vars[Math.min(1, vars.length-1)];
}

function setDateLimits(){
  const rows = state.datasets[DEFAULT_CITY] || [];
  if(!rows.length) return;
  const dates = rows.map(r=>r.__date).sort();
  const min = dates[0], max = dates[dates.length-1];
  const a = document.getElementById("dateStart");
  const b = document.getElementById("dateEnd");
  a.min=min; a.max=max; b.min=min; b.max=max;
  if(!a.value) a.value = min;
  if(!b.value) b.value = max;
}

function updateVarInfo(col){
  const box = document.getElementById("varInfo");
  const d = describeVar(col);
  box.innerHTML = `<b>${niceName(col)}</b><br>
  <span class="muted">Unidade:</span> ${d.unit || "—"}<br>
  <span class="muted">Significado ambiental:</span> ${d.meaning}<br>
  ${d.note ? `<span class="muted">Obs.:</span> ${d.note}` : ""}`;
}

function updateKPIs(values, unitHint){
  const kpis = document.getElementById("kpis");
  const clean = values.filter(v=>isFinite(v));
  const mean = clean.reduce((a,b)=>a+b,0)/clean.length;
  const min = Math.min(...clean);
  const max = Math.max(...clean);
  kpis.innerHTML = `
    <div class="kpi"><div class="k">Média</div><div class="v">${fmt(mean)} ${unitHint||""}</div></div>
    <div class="kpi"><div class="k">Mín</div><div class="v">${fmt(min)} ${unitHint||""}</div></div>
    <div class="kpi"><div class="k">Máx</div><div class="v">${fmt(max)} ${unitHint||""}</div></div>
  `;
}

function updateTrend(values, unitHint, agg){
  const box = document.getElementById("trendBox");
  const clean = values.filter(v=>isFinite(v));
  const mk = mannKendall(clean);
  if(!mk){
    box.className = "note good";
    box.textContent = "Tendência: série curta demais para Mann-Kendall (precisa ≥ 8 pontos).";
    return;
  }
  const direction = mk.sen>0 ? "aumentando" : (mk.sen<0 ? "diminuindo" : "estável");
  const per = agg==="daily" ? "dia" : (agg==="monthly" ? "mês" : "ano");
  const slopeTxt = `${fmt(mk.sen)} ${unitHint||""}/${per}`;
  const sig = mk.p < 0.05 ? "significativa (p<0,05)" : "não significativa (p≥0,05)";
  box.className = "note good";
  box.innerHTML = `<b>Tendência</b>: ${direction} • Sen slope = <b>${slopeTxt}</b> • Mann-Kendall p = <b>${mk.p.toExponential(2)}</b> (${sig})`;
}

/* =========================
   Plots
========================= */
function plotTS(seriesByCity, col, unitHint, reducerUsed){
  const traces = [];
  for(const [city, s] of seriesByCity.entries()){
    traces.push({
      type:"scatter",
      mode:"lines",
      name: city,
      x: s.t,
      y: s.y,
      hovertemplate: `${city}<br>%{x}<br>%{y:.3f} ${unitHint||""}<extra></extra>`
    });
  }

  const layout = {
    margin:{l:50,r:15,t:10,b:50},
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"#fff",
    xaxis:{title:"Tempo"},
    yaxis:{title:`${niceName(col)} ${unitHint?`(${unitHint})`:""}`},
    legend:{orientation:"h"},
  };

  Plotly.newPlot("plot", traces, layout, {responsive:true, displayModeBar:true});
}

function plotBox(rowsByCity, col){
  const traces=[];
  for(const [city, rows] of rowsByCity.entries()){
    const byMonth = new Map();
    for(const r of rows){
      const v = Number(r[col]);
      if(!isFinite(v)) continue;
      const m = r.__month;
      if(!byMonth.has(m)) byMonth.set(m, []);
      byMonth.get(m).push(v);
    }
    // convert per city based on global conversion
    for(let m=1;m<=12;m++){
      const arr = byMonth.get(m) || [];
      const conv = convertIfNeeded(col, arr);
      traces.push({
        type:"box",
        name:`${city} - ${String(m).padStart(2,"0")}`,
        y: conv.arr,
        boxpoints:false,
        hovertemplate: `${city} • mês ${m}<br>%{y:.3f}<extra></extra>`
      });
    }
  }
  const convEmpty = convertIfNeeded(col, [1]);
  const unitHint = convEmpty.unitHint;
  const layout = {
    margin:{l:50,r:15,t:10,b:90},
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"#fff",
    yaxis:{title:`${niceName(col)} ${unitHint?`(${unitHint})`:""}`},
    xaxis:{tickangle: -45},
    showlegend:false
  };
  Plotly.newPlot("plot", traces, layout, {responsive:true, displayModeBar:true});
}

function plotScatter(rowsByCity, xcol, ycol, agg, reducer, lag){
  // use DEFAULT_CITY only for scatter (clean & clear), but allow if multiple selected? keep first city.
  const city = getSelectedCities()[0];
  const rows = rowsByCity.get(city) || [];

  const sx = groupAgg(rows, xcol, agg, reducer);
  const sy = groupAgg(rows, ycol, agg, reducer);

  // align by time
  const mapY = new Map();
  for(let i=0;i<sy.t.length;i++) mapY.set(sy.t[i], sy.y[i]);

  const xs=[], ys=[];
  for(let i=0;i<sx.t.length;i++){
    const t = sx.t[i];
    const idx = i + Number(lag);
    if(idx < 0 || idx >= sy.t.length) continue;
    const yv = sy.y[idx];
    const xv = sx.y[i];
    if(isFinite(xv) && isFinite(yv)) { xs.push(xv); ys.push(yv); }
  }
  if(xs.length<8){
    Plotly.newPlot("plot", [], {annotations:[{text:"Pontos insuficientes para dispersão.", x:0.5,y:0.5, xref:"paper",yref:"paper",showarrow:false}]}, {responsive:true});
    return;
  }
  const r = pearson(xs,ys);
  const rho = spearman(xs,ys);
  const ols = olsSlopeP(xs,ys);

  const trace = {
    type:"scatter",
    mode:"markers",
    name:"Pontos",
    x: xs,
    y: ys,
  };

  // regression line
  const xmin = Math.min(...xs), xmax = Math.max(...xs);
  const line = {
    type:"scatter",
    mode:"lines",
    name:"Regressão",
    x: [xmin, xmax],
    y: [ols.intercept + ols.slope*xmin, ols.intercept + ols.slope*xmax],
  };

  const layout = {
    margin:{l:55,r:15,t:20,b:55},
    paper_bgcolor:"rgba(0,0,0,0)",
    plot_bgcolor:"#fff",
    xaxis:{title:`${niceName(xcol)} ${sx.unitHint?`(${sx.unitHint})`:""}`},
    yaxis:{title:`${niceName(ycol)} ${sy.unitHint?`(${sy.unitHint})`:""}`},
    annotations: [{
      text: `Cidade: <b>${city}</b><br>Pearson r=${r.toFixed(3)} (R²=${(r*r).toFixed(3)})<br>Spearman ρ=${rho.toFixed(3)}<br>Slope=${fmt(ols.slope)} (p=${ols.p.toExponential(2)})<br>Lag(Y)=${lag}`,
      x: 0.01, y: 0.99, xref:"paper", yref:"paper",
      xanchor:"left", yanchor:"top",
      showarrow:false,
      align:"left",
      bgcolor:"rgba(255,255,255,.85)",
      bordercolor:"rgba(37,99,235,.25)",
      borderwidth:1
    }]
  };

  Plotly.newPlot("plot", [trace, line], layout, {responsive:true, displayModeBar:true});
}

function renderTable(seriesByCity, col, unitHint){
  const wrap = document.getElementById("tableWrap");
  wrap.innerHTML = "";
  const cities = [...seriesByCity.keys()];
  const base = seriesByCity.get(cities[0]);
  const rows = [];
  for(let i=0;i<base.t.length;i++){
    const row = {date: base.t[i]};
    for(const c of cities){
      row[c] = seriesByCity.get(c).y[i];
    }
    rows.push(row);
  }
  // simple table
  const table = document.createElement("table");
  table.style.width="100%";
  table.style.borderCollapse="collapse";
  table.innerHTML = `
    <thead>
      <tr>
        <th style="text-align:left;border-bottom:1px solid var(--line);padding:8px">Data</th>
        ${cities.map(c=>`<th style="text-align:right;border-bottom:1px solid var(--line);padding:8px">${c} ${unitHint?`(${unitHint})`:""}</th>`).join("")}
      </tr>
    </thead>
  `;
  const tb = document.createElement("tbody");
  for(const r of rows.slice(-400)){ // keep it light
    const tr=document.createElement("tr");
    tr.innerHTML = `
      <td style="padding:6px 8px;border-bottom:1px solid var(--line);font-family:ui-monospace, SFMono-Regular, Menlo, monospace">${r.date}</td>
      ${cities.map(c=>`<td style="padding:6px 8px;border-bottom:1px solid var(--line);text-align:right">${fmt(r[c])}</td>`).join("")}
    `;
    tb.appendChild(tr);
  }
  table.appendChild(tb);
  wrap.appendChild(table);
}

/* =========================
   Main recompute
========================= */
function getRowsBySelectedCity(){
  const cities = getSelectedCities();
  const map = new Map();
  for(const c of cities){
    map.set(c, state.datasets[c] || []);
  }
  return map;
}

function recalc(){
  const col = document.getElementById("selVar").value;
  const agg = document.getElementById("selAgg").value;
  const reducer = document.getElementById("selReducer").value;
  const start = document.getElementById("dateStart").value;
  const end = document.getElementById("dateEnd").value;

  updateVarInfo(col);

  const rowsByCity = getRowsBySelectedCity();
  const seriesByCity = new Map();
  let anySeries = null;

  for(const [city, rows0] of rowsByCity.entries()){
    const rows = filterByDate(rows0, start, end);
    const s = groupAgg(rows, col, agg, reducer);
    seriesByCity.set(city, s);
    anySeries = s;
  }

  const unitHint = anySeries?.unitHint || "";
  const reducerUsed = anySeries?.reducerUsed || (reducer==="auto"?autoReducer(col):reducer);

  // KPIs + trend based on first selected city (clear)
  const firstCity = getSelectedCities()[0];
  const firstSeries = seriesByCity.get(firstCity);
  if(firstSeries){
    updateKPIs(firstSeries.y, unitHint);
    updateTrend(firstSeries.y, unitHint, agg);
  }

  // tab render
  document.getElementById("tableWrap").style.display = (state.activeTab==="table") ? "block" : "none";
  if(state.activeTab==="ts"){
    plotTS(seriesByCity, col, unitHint, reducerUsed);
  }else if(state.activeTab==="box"){
    plotBox(rowsByCity, col);
  }else if(state.activeTab==="scatter"){
    const xcol = document.getElementById("selX").value;
    const ycol = document.getElementById("selY").value;
    const lag = document.getElementById("selLag").value;
    plotScatter(rowsByCity, xcol, ycol, agg, reducer, lag);
  }else if(state.activeTab==="table"){
    Plotly.purge("plot");
    renderTable(seriesByCity, col, unitHint);
  }
}

function setActiveTab(tab){
  state.activeTab = tab;
  for(const b of document.querySelectorAll(".tab")){
    b.classList.toggle("active", b.dataset.tab===tab);
  }
  recalc();
}

/* =========================
   Load initial + add cities
========================= */
function setSpinner(on, txt){
  const s = document.getElementById("spin");
  const t = document.getElementById("spinTxt");
  if(txt) t.textContent = txt;
  s.style.display = on ? "flex" : "none";
}

async function loadCityFromCSVText(cityName, csvText){
  const parsed = Papa.parse(csvText, {header:true, dynamicTyping:true, skipEmptyLines:true});
  const rows = parseRows(parsed.data);
  if(!rows.length) throw new Error("CSV sem linhas válidas.");
  state.datasets[cityName] = rows;

  // update vars from union
  const cols = Object.keys(rows[0]).filter(k=>!k.startsWith("__"));
  const core = cols.filter(c=>c!=="__dt" && c!=="__date" && c!=="__year" && c!=="__month");
  const set = new Set([...state.vars, ...core]);
  state.vars = [...set].filter(v=>!v.startsWith("__"));
}

async function init(){
  setSpinner(true, "Carregando Cáceres (CSV compactado)…");
  const text = await loadGzText(DATA_URL);
  await loadCityFromCSVText(DEFAULT_CITY, text);

  buildCitySelect();
  buildVarSelects();
  setDateLimits();

  // defaults: pick a temperature-like variable if exists
  const preferred = ["temperature_2m", "temperature_2m_max", "temperature_2m_min", "total_precipitation_sum", "dewpoint_temperature_2m"];
  const selVar = document.getElementById("selVar");
  for(const p of preferred){
    if([...selVar.options].some(o=>o.value===p)){ selVar.value=p; break; }
  }

  setSpinner(false);

  // listeners
  document.getElementById("selCities").addEventListener("change", recalc);
  document.getElementById("selVar").addEventListener("change", recalc);
  document.getElementById("selAgg").addEventListener("change", recalc);
  document.getElementById("selReducer").addEventListener("change", recalc);
  document.getElementById("dateStart").addEventListener("change", recalc);
  document.getElementById("dateEnd").addEventListener("change", recalc);
  document.getElementById("chkHideSnow").addEventListener("change", ()=>{
    buildVarSelects();
    recalc();
  });
  document.getElementById("selX").addEventListener("change", recalc);
  document.getElementById("selY").addEventListener("change", recalc);
  document.getElementById("selLag").addEventListener("change", recalc);

  for(const b of document.querySelectorAll(".tab")){
    b.addEventListener("click", ()=>setActiveTab(b.dataset.tab));
  }

  document.getElementById("btnReset").addEventListener("click", ()=>{
    document.getElementById("selAgg").value="daily";
    document.getElementById("selReducer").value="auto";
    document.getElementById("chkHideSnow").checked=true;
    setDateLimits();
    buildVarSelects();
    recalc();
  });

  document.getElementById("btnPNG").addEventListener("click", async ()=>{
    const gd = document.getElementById("plot");
    try{
      const img = await Plotly.toImage(gd, {format:"png", height:900, width:1400});
      const a = document.createElement("a");
      a.href = img; a.download = "plac_caceres_grafico.png";
      a.click();
    }catch(e){
      alert("Não consegui exportar PNG. Abra um gráfico primeiro.");
    }
  });

  document.getElementById("btnCSV").addEventListener("click", ()=>{
    const col = document.getElementById("selVar").value;
    const agg = document.getElementById("selAgg").value;
    const reducer = document.getElementById("selReducer").value;
    const start = document.getElementById("dateStart").value;
    const end = document.getElementById("dateEnd").value;

    const city = getSelectedCities()[0];
    const rows0 = state.datasets[city] || [];
    const rows = filterByDate(rows0, start, end);
    const s = groupAgg(rows, col, agg, reducer);
    const header = ["date", col].join(",");
    const lines = s.t.map((t,i)=>`${t},${s.y[i]}`);
    const csv = header + "\n" + lines.join("\n");
    downloadBlob(`plac_${city}_${col}_${agg}.csv`, "text/csv;charset=utf-8", csv);
  });

  document.getElementById("btnAddCity").addEventListener("click", ()=>document.getElementById("fileCity").click());

  document.getElementById("fileCity").addEventListener("change", async (ev)=>{
    const f = ev.target.files?.[0];
    if(!f) return;
    const name = f.name.replace(/\.(csv|gz|csv\.gz)$/i,"").replaceAll("_"," ").trim() || "Município";
    setSpinner(true, "Importando " + name + "…");

    try{
      let text;
      if(f.name.toLowerCase().endsWith(".gz")){
        const buf = await f.arrayBuffer();
        const dec = window.pako.ungzip(new Uint8Array(buf));
        text = new TextDecoder("utf-8").decode(dec);
      }else{
        text = await f.text();
      }
      await loadCityFromCSVText(name, text);
      buildCitySelect();
      buildVarSelects();
      // select newly added too
      const sel = document.getElementById("selCities");
      [...sel.options].forEach(o=>{ if(o.value===name) o.selected=true; });
      setSpinner(false);
      recalc();
    }catch(err){
      console.error(err);
      setSpinner(false);
      alert("Falha ao importar município: " + err.message);
    }finally{
      ev.target.value="";
    }
  });

  document.getElementById("btnRemoveCity").addEventListener("click", ()=>{
    const sel = document.getElementById("selCities");
    const chosen = [...sel.options].filter(o=>o.selected).map(o=>o.value);
    for(const c of chosen){
      if(c===DEFAULT_CITY) continue;
      delete state.datasets[c];
    }
    buildCitySelect();
    buildVarSelects();
    recalc();
  });

  recalc();
}

/* =========================
   Start
========================= */
init().catch(err=>{
  console.error(err);
  alert("Erro ao iniciar o painel! Não consegui carregar: " + (err.message||err));
});
</script>
</body>
</html>